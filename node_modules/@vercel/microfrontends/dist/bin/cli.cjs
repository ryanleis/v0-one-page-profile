#!/usr/bin/env node
"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));

// src/bin/index.ts
var import_commander = require("commander");
var import_env = require("@next/env");

// package.json
var package_default = {
  name: "@vercel/microfrontends",
  version: "1.2.0",
  private: false,
  description: "Defines configuration and utilities for microfrontends development",
  keywords: [
    "microfrontends",
    "Next.js"
  ],
  homepage: "https://vercel.com/docs/microfrontends",
  repository: {
    type: "git",
    url: "https://github.com/vercel/microfrontends.git",
    directory: "packages/microfrontends"
  },
  sideEffects: false,
  type: "module",
  exports: {
    "./schema.json": "./schema/schema.json",
    "./validation": {
      import: "./dist/validation.js",
      require: "./dist/validation.cjs"
    },
    "./config": {
      import: "./dist/config.js",
      require: "./dist/config.cjs"
    },
    "./experimental/sveltekit": {
      import: "./dist/experimental/sveltekit.js",
      require: "./dist/experimental/sveltekit.cjs"
    },
    "./experimental/vite": {
      import: "./dist/experimental/vite.js",
      require: "./dist/experimental/vite.cjs"
    },
    "./overrides": {
      import: "./dist/overrides.js",
      require: "./dist/overrides.cjs"
    },
    "./microfrontends/server": {
      import: "./dist/microfrontends/server.js",
      require: "./dist/microfrontends/server.cjs"
    },
    "./microfrontends/utils": {
      import: "./dist/microfrontends/utils.js",
      require: "./dist/microfrontends/utils.cjs"
    },
    "./schema": {
      import: "./dist/schema.js",
      require: "./dist/schema.cjs"
    },
    "./next/config": {
      import: "./dist/next/config.js",
      require: "./dist/next/config.cjs"
    },
    "./next/middleware": {
      import: "./dist/next/middleware.js",
      require: "./dist/next/middleware.cjs"
    },
    "./next/endpoints": {
      import: "./dist/next/endpoints.js",
      require: "./dist/next/endpoints.cjs"
    },
    "./next/testing": {
      import: "./dist/next/testing.js",
      require: "./dist/next/testing.cjs"
    },
    "./next/client": {
      import: "./dist/next/client.js",
      require: "./dist/next/client.cjs"
    },
    "./utils/mfe-port": {
      import: "./dist/utils/mfe-port.js",
      require: "./dist/utils/mfe-port.cjs"
    }
  },
  typesVersions: {
    "*": {
      validation: [
        "./dist/validation.d.ts"
      ],
      config: [
        "./dist/config.d.ts"
      ],
      "experimental/sveltekit": [
        "./dist/experimental/sveltekit.d.ts"
      ],
      "experimental/vite": [
        "./dist/experimental/vite.d.ts"
      ],
      overrides: [
        "./dist/overrides.d.ts"
      ],
      "microfrontends/server": [
        "./dist/microfrontends/server.d.ts"
      ],
      "microfrontends/utils": [
        "./dist/microfrontends/utils.d.ts"
      ],
      schema: [
        "./dist/schema.d.ts"
      ],
      "next/config": [
        "./dist/next/config.d.ts"
      ],
      "next/middleware": [
        "./dist/next/middleware.d.ts"
      ],
      "next/endpoints": [
        "./dist/next/endpoints.d.ts"
      ],
      "next/testing": [
        "./dist/next/testing.d.ts"
      ],
      "next/client": [
        "./dist/next/client.d.ts"
      ],
      "utils/mfe-port": [
        "./dist/utils/mfe-port.d.ts"
      ]
    }
  },
  bin: {
    microfrontends: "./cli/index.cjs"
  },
  files: [
    "dist",
    "schema"
  ],
  scripts: {
    build: "tsup",
    postbuild: "pnpm generate:exports",
    "generate:exports": "tsx scripts/generate-exports/index.ts",
    "generate:schema": "tsx scripts/generate-json-schema.ts",
    lint: "eslint .",
    "lint-fix": "eslint . --fix",
    prepublishOnly: "pnpm build && pnpm generate:exports && pnpm generate:schema",
    proxy: "tsx src/proxy/index.ts",
    test: "cross-env TZ=UTC jest",
    typecheck: "tsc --noEmit"
  },
  dependencies: {
    "@next/env": "15.1.6",
    ajv: "^8.17.1",
    commander: "^12.1.0",
    cookie: "0.4.0",
    "fast-glob": "^3.3.2",
    "http-proxy": "^1.18.1",
    "jsonc-parser": "^3.3.1",
    nanoid: "^3.3.9",
    "path-to-regexp": "6.2.1"
  },
  devDependencies: {
    "@edge-runtime/jest-environment": "^4.0.0",
    "@edge-runtime/types": "^3.0.2",
    "@sveltejs/kit": "2.17.2",
    "@testing-library/react": "^15.0.7",
    "@types/cookie": "0.5.1",
    "@types/http-proxy": "^1.17.15",
    "@types/jest": "^29.2.0",
    "@types/json-schema": "^7.0.15",
    "@types/node": "20.11.30",
    "@types/react": "18.3.1",
    "@types/react-dom": "18.3.0",
    "eslint-config-custom": "workspace:*",
    jest: "^29.7.0",
    "jest-environment-jsdom": "29.2.2",
    next: "15.1.6",
    react: "19.0.0",
    "react-dom": "19.0.0",
    "ts-config": "workspace:*",
    "ts-json-schema-generator": "^1.1.2",
    "ts-node": "~10.9.2",
    tsup: "^6.6.2",
    tsx: "^4.6.2",
    typescript: "5.7.3",
    vite: "5.4.11",
    webpack: "5"
  },
  peerDependencies: {
    "@sveltejs/kit": ">=1",
    "@vercel/analytics": ">=1.5.0",
    "@vercel/speed-insights": ">=1.2.0",
    next: ">=13",
    react: ">=17.0.0",
    "react-dom": ">=17.0.0",
    vite: ">=5"
  },
  peerDependenciesMeta: {
    "@sveltejs/kit": {
      optional: true
    },
    "@vercel/analytics": {
      optional: true
    },
    "@vercel/speed-insights": {
      optional: true
    },
    next: {
      optional: true
    },
    react: {
      optional: true
    },
    "react-dom": {
      optional: true
    },
    vite: {
      optional: true
    }
  }
};

// src/bin/local-proxy.ts
var http = __toESM(require("http"), 1);
var https = __toESM(require("https"), 1);
var import_node_url = require("url");
var import_cookie = require("cookie");
var import_path_to_regexp3 = require("path-to-regexp");
var import_http_proxy = __toESM(require("http-proxy"), 1);

// src/config/microfrontends-config/isomorphic/index.ts
var import_jsonc_parser = require("jsonc-parser");

// src/config/errors.ts
var MicrofrontendError = class extends Error {
  constructor(message, opts) {
    super(message, { cause: opts?.cause });
    this.name = "MicrofrontendsError";
    this.source = opts?.source ?? "@vercel/microfrontends";
    this.type = opts?.type ?? "unknown";
    this.subtype = opts?.subtype;
    Error.captureStackTrace(this, MicrofrontendError);
  }
  isKnown() {
    return this.type !== "unknown";
  }
  isUnknown() {
    return !this.isKnown();
  }
  /**
   * Converts an error to a MicrofrontendsError.
   * @param original - The original error to convert.
   * @returns The converted MicrofrontendsError.
   */
  static convert(original, opts) {
    if (opts?.fileName) {
      const err = MicrofrontendError.convertFSError(original, opts.fileName);
      if (err) {
        return err;
      }
    }
    if (original.message.includes(
      "Code generation from strings disallowed for this context"
    )) {
      return new MicrofrontendError(original.message, {
        type: "config",
        subtype: "unsupported_validation_env",
        source: "ajv"
      });
    }
    return new MicrofrontendError(original.message);
  }
  static convertFSError(original, fileName) {
    if (original instanceof Error && "code" in original) {
      if (original.code === "ENOENT") {
        return new MicrofrontendError(`Could not find "${fileName}"`, {
          type: "config",
          subtype: "unable_to_read_file",
          source: "fs"
        });
      }
      if (original.code === "EACCES") {
        return new MicrofrontendError(
          `Permission denied while accessing "${fileName}"`,
          {
            type: "config",
            subtype: "invalid_permissions",
            source: "fs"
          }
        );
      }
    }
    if (original instanceof SyntaxError) {
      return new MicrofrontendError(
        `Failed to parse "${fileName}": Invalid JSON format.`,
        {
          type: "config",
          subtype: "invalid_syntax",
          source: "fs"
        }
      );
    }
    return null;
  }
  /**
   * Handles an unknown error and returns a MicrofrontendsError instance.
   * @param err - The error to handle.
   * @returns A MicrofrontendsError instance.
   */
  static handle(err, opts) {
    if (err instanceof MicrofrontendError) {
      return err;
    }
    if (err instanceof Error) {
      return MicrofrontendError.convert(err, opts);
    }
    if (typeof err === "object" && err !== null) {
      if ("message" in err && typeof err.message === "string") {
        return MicrofrontendError.convert(new Error(err.message), opts);
      }
    }
    return new MicrofrontendError("An unknown error occurred");
  }
};

// src/config/microfrontends-config/utils/get-config-from-env.ts
function getConfigStringFromEnv() {
  const config = process.env.MFE_CONFIG;
  if (!config) {
    throw new MicrofrontendError(`Missing "MFE_CONFIG" in environment.`, {
      type: "config",
      subtype: "not_found_in_env"
    });
  }
  return config;
}

// src/config/schema/utils/is-default-app.ts
function isDefaultApp(a) {
  return !("routing" in a);
}

// src/config/microfrontends-config/client/index.ts
var import_path_to_regexp = require("path-to-regexp");
var MicrofrontendConfigClient = class {
  constructor(config, opts) {
    this.pathCache = {};
    this.serialized = config;
    if (opts?.removeFlaggedPaths) {
      for (const app of Object.values(config.applications)) {
        if (app.routing) {
          app.routing = app.routing.filter((match) => !match.flag);
        }
      }
    }
    this.applications = config.applications;
  }
  /**
   * Create a new `MicrofrontendConfigClient` from a JSON string.
   * Config must be passed in to remain framework agnostic
   */
  static fromEnv(config, opts) {
    if (!config) {
      throw new Error("No microfrontends configuration found");
    }
    return new MicrofrontendConfigClient(
      JSON.parse(config),
      opts
    );
  }
  isEqual(other) {
    return JSON.stringify(this.applications) === JSON.stringify(other.applications);
  }
  getApplicationNameForPath(path7) {
    if (!path7.startsWith("/")) {
      throw new Error(`Path must start with a /`);
    }
    if (this.pathCache[path7]) {
      return this.pathCache[path7];
    }
    const pathname = new URL(path7, "https://example.com").pathname;
    for (const [name, application] of Object.entries(this.applications)) {
      if (application.routing) {
        for (const group of application.routing) {
          for (const childPath of group.paths) {
            const regexp = (0, import_path_to_regexp.pathToRegexp)(childPath);
            if (regexp.test(pathname)) {
              this.pathCache[path7] = name;
              return name;
            }
          }
        }
      }
    }
    const defaultApplication = Object.entries(this.applications).find(
      ([, application]) => application.default
    );
    if (!defaultApplication) {
      return null;
    }
    this.pathCache[path7] = defaultApplication[0];
    return defaultApplication[0];
  }
  serialize() {
    return this.serialized;
  }
};

// src/config/overrides/constants.ts
var OVERRIDES_COOKIE_PREFIX = "vercel-micro-frontends-override";
var OVERRIDES_ENV_COOKIE_PREFIX = `${OVERRIDES_COOKIE_PREFIX}:env:`;

// src/config/overrides/is-override-cookie.ts
function isOverrideCookie(cookie) {
  return Boolean(cookie.name?.startsWith(OVERRIDES_COOKIE_PREFIX));
}

// src/config/overrides/get-override-from-cookie.ts
function getOverrideFromCookie(cookie) {
  if (!isOverrideCookie(cookie) || !cookie.value)
    return;
  return {
    application: cookie.name.replace(OVERRIDES_ENV_COOKIE_PREFIX, ""),
    host: cookie.value
  };
}

// src/config/overrides/parse-overrides.ts
function parseOverrides(cookies) {
  const overridesConfig = { applications: {} };
  cookies.forEach((cookie) => {
    const override = getOverrideFromCookie(cookie);
    if (!override)
      return;
    overridesConfig.applications[override.application] = {
      environment: { host: override.host }
    };
  });
  return overridesConfig;
}

// src/config/microfrontends-config/isomorphic/validation.ts
var import_path_to_regexp2 = require("path-to-regexp");
var LIST_FORMATTER = new Intl.ListFormat("en", {
  style: "long",
  type: "conjunction"
});
var validateConfigPaths = (applicationConfigsById) => {
  if (!applicationConfigsById) {
    return;
  }
  const pathsByApplicationId = /* @__PURE__ */ new Map();
  const errors = [];
  for (const [id, app] of Object.entries(applicationConfigsById)) {
    if (isDefaultApp(app)) {
      continue;
    }
    for (const pathMatch of app.routing) {
      for (const path7 of pathMatch.paths) {
        const maybeError = validatePathExpression(path7);
        if (maybeError) {
          errors.push(maybeError);
        } else {
          const existing = pathsByApplicationId.get(path7);
          if (existing) {
            existing.applications.push(id);
          } else {
            pathsByApplicationId.set(path7, {
              applications: [id],
              matcher: (0, import_path_to_regexp2.pathToRegexp)(path7),
              applicationId: id
            });
          }
        }
      }
    }
  }
  const entries = Array.from(pathsByApplicationId.entries());
  for (const [path7, { applications: ids, matcher, applicationId }] of entries) {
    if (ids.length > 1) {
      errors.push(
        `Duplicate path "${path7}" for applications "${ids.join(", ")}"`
      );
    }
    for (const [
      matchPath,
      { applications: matchIds, applicationId: matchApplicationId }
    ] of entries) {
      if (path7 === matchPath) {
        continue;
      }
      if (applicationId === matchApplicationId) {
        continue;
      }
      if (matcher.test(matchPath)) {
        const source = `"${path7}" of application${ids.length > 0 ? "s" : ""} ${ids.join(", ")}`;
        const destination = `"${matchPath}" of application${matchIds.length > 0 ? "s" : ""} ${matchIds.join(", ")}`;
        errors.push(
          `Overlapping path detected between ${source} and ${destination}`
        );
      }
    }
  }
  if (errors.length) {
    throw new MicrofrontendError(
      `Invalid paths: ${errors.join(", ")}. See supported paths in the documentation https://vercel.com/docs/microfrontends/path-routing#supported-path-expressions.`,
      {
        type: "config",
        subtype: "conflicting_paths"
      }
    );
  }
};
var PATH_DEFAULT_PATTERN = "[^\\/#\\?]+?";
function validatePathExpression(path7) {
  try {
    const tokens = (0, import_path_to_regexp2.parse)(path7);
    if (/(?<!\\)\{/.test(path7)) {
      return `Optional paths are not supported: ${path7}`;
    }
    if (/(?<!\\|\()\?/.test(path7)) {
      return `Optional paths are not supported: ${path7}`;
    }
    if (/\/[^/]*(?<!\\):[^/]*(?<!\\):[^/]*/.test(path7)) {
      return `Only one wildcard is allowed per path segment: ${path7}`;
    }
    for (let i = 0; i < tokens.length; i++) {
      const token = tokens[i];
      if (token === void 0) {
        return `token ${i} in ${path7} is undefined, this shouldn't happen`;
      }
      if (typeof token !== "string") {
        if (!token.name) {
          return `Only named wildcards are allowed: ${path7} (hint: add ":path" to the wildcard)`;
        }
        if (token.pattern !== PATH_DEFAULT_PATTERN && // Allows (a|b|c) and ((?!a|b|c).*) regex
        // Only limited regex is supported for now, due to performance considerations
        !/^(?<allowed>[\w]+(?:\|[^:|()]+)+)$|^\(\?!(?<disallowed>[\w]+(?:\|[^:|()]+)*)\)\.\*$/.test(
          token.pattern
        )) {
          return `Path ${path7} cannot use unsupported regular expression wildcard`;
        }
        if (token.modifier && i !== tokens.length - 1) {
          return `Modifier ${token.modifier} is not allowed on wildcard :${token.name} in ${path7}. Modifiers are only allowed in the last path component`;
        }
      }
    }
  } catch (e) {
    const message = e instanceof Error ? e.message : String(e);
    return `Path ${path7} could not be parsed into regexp: ${message}`;
  }
  return void 0;
}
var validateAppPaths = (name, app) => {
  for (const group of app.routing) {
    for (const p of group.paths) {
      if (p === "/") {
        continue;
      }
      if (p.endsWith("/")) {
        throw new MicrofrontendError(
          `Invalid path for application "${name}". ${p} must not end with a slash.`,
          { type: "application", subtype: "invalid_path" }
        );
      }
      if (!p.startsWith("/")) {
        throw new MicrofrontendError(
          `Invalid path for application "${name}". ${p} must start with a slash.`,
          { type: "application", subtype: "invalid_path" }
        );
      }
    }
  }
};
var validateConfigDefaultApplication = (applicationConfigsById) => {
  if (!applicationConfigsById) {
    return;
  }
  const applicationsWithoutRouting = Object.entries(
    applicationConfigsById
  ).filter(([, app]) => isDefaultApp(app));
  const numApplicationsWithoutRouting = applicationsWithoutRouting.reduce(
    (acc) => {
      return acc + 1;
    },
    0
  );
  if (numApplicationsWithoutRouting === 0) {
    throw new MicrofrontendError(
      "No default application found. At least one application needs to be the default by omitting routing.",
      { type: "config", subtype: "no_default_application" }
    );
  }
  if (numApplicationsWithoutRouting > 1) {
    const applicationNamesMissingRouting = applicationsWithoutRouting.map(
      ([name]) => name
    );
    throw new MicrofrontendError(
      `All applications except for the default app must contain the "routing" field. Applications that are missing routing: ${LIST_FORMATTER.format(applicationNamesMissingRouting)}.`,
      { type: "config", subtype: "multiple_default_applications" }
    );
  }
};
var validateDeprecatedFields = (config) => {
  const errors = [];
  for (const [applicationId, application] of Object.entries(
    config.applications
  )) {
    if (application.development?.localPort) {
      errors.push(
        `Application '${applicationId}' cannot contain deprecated field 'development.localPort'. Use 'developement.local' instead.`
      );
    }
    if (application.projectId) {
    }
  }
  if (errors.length) {
    throw new MicrofrontendError(
      `Microfrontends configuration file errors:
- ${errors.join("\n- ")}`,
      {
        type: "config",
        subtype: "depcrecated_field"
      }
    );
  }
};

// src/config/microfrontends-config/isomorphic/utils/generate-asset-prefix.ts
var PREFIX = "vc-ap";
function generateAssetPrefixFromName({
  name
}) {
  if (!name) {
    throw new Error("Name is required to generate an asset prefix");
  }
  return `${PREFIX}-${name}`;
}

// src/config/microfrontends-config/isomorphic/utils/generate-port.ts
function generatePortFromName({
  name,
  minPort = 3e3,
  maxPort = 8e3
}) {
  if (!name) {
    throw new Error("Name is required to generate a port");
  }
  let hash = 0;
  for (let i = 0; i < name.length; i++) {
    hash = (hash << 5) - hash + name.charCodeAt(i);
    hash |= 0;
  }
  hash = Math.abs(hash);
  const range = maxPort - minPort;
  const port = minPort + hash % range;
  return port;
}

// src/config/microfrontends-config/isomorphic/host.ts
var Host = class {
  constructor(hostConfig, options) {
    if (typeof hostConfig === "string") {
      ({
        protocol: this.protocol,
        host: this.host,
        port: this.port
      } = Host.parseUrl(hostConfig));
    } else {
      const { protocol = "https", host, port } = hostConfig;
      this.protocol = protocol;
      this.host = host;
      this.port = port;
    }
    this.local = options?.isLocal;
  }
  static parseUrl(url, defaultProtocol = "https") {
    let hostToParse = url;
    if (!/^https?:\/\//.exec(hostToParse)) {
      hostToParse = `${defaultProtocol}://${hostToParse}`;
    }
    const parsed = new URL(hostToParse);
    if (!parsed.hostname) {
      throw new Error(Host.getMicrofrontendsError(url, "requires a host"));
    }
    if (parsed.hash) {
      throw new Error(
        Host.getMicrofrontendsError(url, "cannot have a fragment")
      );
    }
    if (parsed.username || parsed.password) {
      throw new Error(
        Host.getMicrofrontendsError(
          url,
          "cannot have authentication credentials (username and/or password)"
        )
      );
    }
    if (parsed.pathname !== "/") {
      throw new Error(Host.getMicrofrontendsError(url, "cannot have a path"));
    }
    if (parsed.search) {
      throw new Error(
        Host.getMicrofrontendsError(url, "cannot have query parameters")
      );
    }
    const protocol = parsed.protocol.slice(0, -1);
    return {
      protocol,
      host: parsed.hostname,
      port: parsed.port ? Number.parseInt(parsed.port) : void 0
    };
  }
  static getMicrofrontendsError(url, message) {
    return `Microfrontends configuration error: the URL ${url} in your microfrontends.json ${message}.`;
  }
  isLocal() {
    return this.local || this.host === "localhost" || this.host === "127.0.0.1";
  }
  toString() {
    const url = this.toUrl();
    return url.toString().replace(/\/$/, "");
  }
  toUrl() {
    const url = `${this.protocol}://${this.host}${this.port ? `:${this.port}` : ""}`;
    return new URL(url);
  }
};
var LocalHost = class extends Host {
  constructor({
    appName,
    localPort,
    local
  }) {
    if (localPort && local) {
      throw new Error(
        `Microfrontends configuration error: '${appName}' has both the 'development.local' and 'development.localPort' fields set. Please remove the 'development.localPort' field and ensure the 'development.local' field has the correct port.`
      );
    }
    let protocol;
    let host;
    let port;
    if (localPort) {
      port = localPort;
    } else if (typeof local === "number") {
      port = local;
    } else if (typeof local === "string") {
      if (/^\d+$/.test(local)) {
        port = Number.parseInt(local);
      } else {
        const parsed = Host.parseUrl(local, "http");
        protocol = parsed.protocol;
        host = parsed.host;
        port = parsed.port;
      }
    } else if (local) {
      protocol = local.protocol;
      host = local.host;
      port = local.port;
    }
    super({
      protocol: protocol ?? "http",
      host: host ?? "localhost",
      port: port ?? generatePortFromName({ name: appName })
    });
  }
};

// src/config/microfrontends-config/isomorphic/utils/generate-automation-bypass-env-var-name.ts
function generateAutomationBypassEnvVarName({
  name
}) {
  return `AUTOMATION_BYPASS_${name.toUpperCase().replace(/[^a-zA-Z0-9]/g, "_")}`;
}

// src/config/microfrontends-config/isomorphic/application.ts
var Application = class {
  constructor(name, {
    app,
    overrides,
    isDefault
  }) {
    this.name = name;
    this.development = {
      local: new LocalHost({
        appName: name,
        localPort: app.development?.localPort,
        local: app.development?.local
      }),
      fallback: app.development?.fallback ? new Host(app.development.fallback) : void 0
    };
    if (app.development?.fallback) {
      this.fallback = new Host(app.development.fallback);
    }
    this.projectId = app.projectId;
    this.packageName = app.packageName;
    this.overrides = overrides?.environment ? {
      environment: new Host(overrides.environment)
    } : void 0;
    this.default = isDefault ?? false;
    this.serialized = app;
  }
  isDefault() {
    return this.default;
  }
  getAssetPrefix() {
    return generateAssetPrefixFromName({ name: this.name });
  }
  getAutomationBypassEnvVarName() {
    return generateAutomationBypassEnvVarName({ name: this.name });
  }
  serialize() {
    return this.serialized;
  }
};
var DefaultApplication = class extends Application {
  constructor(name, {
    app,
    overrides
  }) {
    super(name, {
      app,
      overrides,
      isDefault: true
    });
    this.default = true;
    this.fallback = new Host(app.development.fallback);
  }
  getAssetPrefix() {
    return "";
  }
};
var ChildApplication = class extends Application {
  constructor(name, {
    app,
    overrides
  }) {
    ChildApplication.validate(name, app);
    super(name, {
      app,
      overrides,
      isDefault: false
    });
    this.default = false;
    this.routing = app.routing;
  }
  static validate(name, app) {
    validateAppPaths(name, app);
  }
};

// src/config/microfrontends-config/isomorphic/constants.ts
var DEFAULT_LOCAL_PROXY_PORT = 3024;

// src/config/microfrontends-config/isomorphic/index.ts
var MicrofrontendConfigIsomorphic = class {
  constructor({
    config,
    overrides,
    opts
  }) {
    this.childApplications = {};
    MicrofrontendConfigIsomorphic.validate(config, opts);
    const disableOverrides = config.options?.disableOverrides ?? false;
    this.overrides = overrides && !disableOverrides ? overrides : void 0;
    let defaultApplication;
    for (const [appId, appConfig] of Object.entries(config.applications)) {
      const appOverrides = !disableOverrides ? this.overrides?.applications[appId] : void 0;
      if (isDefaultApp(appConfig)) {
        defaultApplication = new DefaultApplication(appId, {
          app: appConfig,
          overrides: appOverrides
        });
      } else {
        this.childApplications[appId] = new ChildApplication(appId, {
          app: appConfig,
          overrides: appOverrides
        });
      }
    }
    if (!defaultApplication) {
      throw new MicrofrontendError(
        "Could not find default application in microfrontends configuration",
        {
          type: "application",
          subtype: "not_found"
        }
      );
    }
    this.defaultApplication = defaultApplication;
    this.config = config;
    this.options = config.options;
    this.serialized = {
      config,
      overrides
    };
  }
  static validate(config, opts) {
    const skipValidation = opts?.skipValidation ?? [];
    const c = typeof config === "string" ? (0, import_jsonc_parser.parse)(config) : config;
    validateConfigPaths(c.applications);
    validateConfigDefaultApplication(c.applications);
    if (!skipValidation.includes("deprecatedFields")) {
      validateDeprecatedFields(c);
    }
    return c;
  }
  static fromEnv({
    cookies
  }) {
    return new MicrofrontendConfigIsomorphic({
      config: (0, import_jsonc_parser.parse)(getConfigStringFromEnv()),
      overrides: parseOverrides(cookies ?? [])
    });
  }
  isOverridesDisabled() {
    return this.options?.disableOverrides ?? false;
  }
  getConfig() {
    return this.config;
  }
  getApplicationsByType() {
    return {
      defaultApplication: this.defaultApplication,
      applications: Object.values(this.childApplications)
    };
  }
  getChildApplications() {
    return Object.values(this.childApplications);
  }
  getAllApplications() {
    return [
      this.defaultApplication,
      ...Object.values(this.childApplications)
    ].filter(Boolean);
  }
  getApplication(name) {
    if (this.defaultApplication.name === name || this.defaultApplication.packageName === name) {
      return this.defaultApplication;
    }
    const app = this.childApplications[name] || Object.values(this.childApplications).find(
      (child) => child.packageName === name
    );
    if (!app) {
      throw new MicrofrontendError(
        `Could not find microfrontends configuration for application "${name}"`,
        {
          type: "application",
          subtype: "not_found"
        }
      );
    }
    return app;
  }
  hasApplication(name) {
    try {
      this.getApplication(name);
      return true;
    } catch {
      return false;
    }
  }
  getApplicationByProjectId(projectId) {
    if (this.defaultApplication.projectId === projectId) {
      return this.defaultApplication;
    }
    return Object.values(this.childApplications).find(
      (app) => app.projectId === projectId
    );
  }
  /**
   * Returns the default application.
   */
  getDefaultApplication() {
    return this.defaultApplication;
  }
  /**
   * Returns the configured port for the local proxy
   */
  getLocalProxyPort() {
    return this.config.options?.localProxyPort ?? DEFAULT_LOCAL_PROXY_PORT;
  }
  /**
   * Serializes the class back to the Schema type.
   *
   * NOTE: This is used when writing the config to disk and must always match the input Schema
   */
  toSchemaJson() {
    return this.serialized.config;
  }
  toClientConfig() {
    const applications = Object.fromEntries(
      Object.entries(this.childApplications).map(([name, application]) => [
        name,
        {
          default: false,
          routing: application.routing
        }
      ])
    );
    applications[this.defaultApplication.name] = {
      default: true
    };
    return new MicrofrontendConfigClient({
      applications
    });
  }
  serialize() {
    return this.serialized;
  }
};

// src/config/microfrontends/server/index.ts
var import_node_fs7 = __toESM(require("fs"), 1);
var import_node_path8 = require("path");

// src/config/microfrontends/utils/find-repository-root.ts
var import_node_fs = __toESM(require("fs"), 1);
var import_node_path = __toESM(require("path"), 1);
var GIT_DIRECTORY = ".git";
function hasGitDirectory(dir) {
  const gitPath = import_node_path.default.join(dir, GIT_DIRECTORY);
  return import_node_fs.default.existsSync(gitPath) && import_node_fs.default.statSync(gitPath).isDirectory();
}
function hasPnpmWorkspaces(dir) {
  return import_node_fs.default.existsSync(import_node_path.default.join(dir, "pnpm-workspace.yaml"));
}
function findRepositoryRoot(startDir) {
  if (process.env.NX_WORKSPACE_ROOT) {
    return process.env.NX_WORKSPACE_ROOT;
  }
  let currentDir = startDir || process.cwd();
  while (currentDir !== import_node_path.default.parse(currentDir).root) {
    if (hasGitDirectory(currentDir) || hasPnpmWorkspaces(currentDir)) {
      return currentDir;
    }
    currentDir = import_node_path.default.dirname(currentDir);
  }
  throw new Error(
    "Repository root not found. Specify the root of the repository with the `repository.root` option."
  );
}

// src/config/microfrontends/utils/find-default-package.ts
var import_node_path2 = require("path");
var import_node_fs2 = require("fs");
var import_jsonc_parser2 = require("jsonc-parser");
var import_fast_glob = __toESM(require("fast-glob"), 1);

// src/config/constants.ts
var CONFIGURATION_FILENAMES = [
  "microfrontends.jsonc",
  "microfrontends.json"
];

// src/config/microfrontends/utils/find-default-package.ts
var configCache = {};
function findDefaultMicrofrontendsPackages({
  repositoryRoot,
  applicationName
}) {
  try {
    const microfrontendsJsonPaths = import_fast_glob.default.globSync(
      `**/{${CONFIGURATION_FILENAMES.join(",")}}`,
      {
        cwd: repositoryRoot,
        absolute: true,
        onlyFiles: true,
        followSymbolicLinks: false,
        ignore: ["**/node_modules/**", "**/.git/**"]
      }
    );
    const matchingPaths = [];
    for (const microfrontendsJsonPath of microfrontendsJsonPaths) {
      try {
        const microfrontendsJsonContent = (0, import_node_fs2.readFileSync)(
          microfrontendsJsonPath,
          "utf-8"
        );
        const microfrontendsJson = (0, import_jsonc_parser2.parse)(microfrontendsJsonContent);
        if (microfrontendsJson.applications[applicationName]) {
          matchingPaths.push(microfrontendsJsonPath);
        }
      } catch (error) {
      }
    }
    if (matchingPaths.length > 1) {
      throw new Error(
        `Found multiple default applications referencing "${applicationName}" in the repository, but only one is allowed.
${matchingPaths.join("\n  \u2022 ")}`
      );
    }
    if (matchingPaths.length === 0) {
      throw new Error(
        `Could not find default application with "applications.${applicationName}"`
      );
    }
    const [packageJsonPath] = matchingPaths;
    return (0, import_node_path2.dirname)(packageJsonPath);
  } catch (error) {
    return null;
  }
}
function findDefaultMicrofrontendsPackage(opts) {
  const cacheKey = `${opts.repositoryRoot}-${opts.applicationName}`;
  if (configCache[cacheKey]) {
    return configCache[cacheKey];
  }
  const result = findDefaultMicrofrontendsPackages(opts);
  if (!result) {
    throw new Error(
      "Error trying to resolve the main microfrontends configuration"
    );
  }
  configCache[cacheKey] = result;
  return result;
}

// src/config/microfrontends/utils/is-monorepo.ts
var import_node_fs3 = __toESM(require("fs"), 1);
var import_node_path3 = __toESM(require("path"), 1);
function isMonorepo({
  repositoryRoot
}) {
  try {
    if (import_node_fs3.default.existsSync(import_node_path3.default.join(repositoryRoot, "pnpm-workspace.yaml"))) {
      return true;
    }
    if (import_node_fs3.default.existsSync(import_node_path3.default.join(repositoryRoot, "vlt-workspaces.json"))) {
      return true;
    }
    if (process.env.NX_WORKSPACE_ROOT === import_node_path3.default.resolve(repositoryRoot)) {
      return true;
    }
    const packageJsonPath = import_node_path3.default.join(repositoryRoot, "package.json");
    if (!import_node_fs3.default.existsSync(packageJsonPath)) {
      return false;
    }
    const packageJson = JSON.parse(
      import_node_fs3.default.readFileSync(packageJsonPath, "utf-8")
    );
    return packageJson.workspaces !== void 0;
  } catch (error) {
    console.error("Error determining if repository is a monorepo", error);
    return false;
  }
}

// src/config/microfrontends/utils/find-package-root.ts
var import_node_fs4 = __toESM(require("fs"), 1);
var import_node_path4 = __toESM(require("path"), 1);
var PACKAGE_JSON = "package.json";
function findPackageRoot(startDir) {
  let currentDir = startDir || process.cwd();
  while (currentDir !== import_node_path4.default.parse(currentDir).root) {
    const pkgJsonPath = import_node_path4.default.join(currentDir, PACKAGE_JSON);
    if (import_node_fs4.default.existsSync(pkgJsonPath)) {
      return currentDir;
    }
    currentDir = import_node_path4.default.dirname(currentDir);
  }
  throw new Error(
    "Package root not found. Specify the root of the package with the `package.root` option."
  );
}

// src/config/microfrontends/utils/find-config.ts
var import_node_fs5 = __toESM(require("fs"), 1);
var import_node_path5 = require("path");
function findConfig({ dir }) {
  for (const filename of CONFIGURATION_FILENAMES) {
    const maybeConfig = (0, import_node_path5.join)(dir, filename);
    if (import_node_fs5.default.existsSync(maybeConfig)) {
      return maybeConfig;
    }
  }
  return null;
}

// src/config/microfrontends/utils/get-application-context.ts
var import_node_fs6 = __toESM(require("fs"), 1);
var import_node_path6 = __toESM(require("path"), 1);
function getApplicationContext(opts) {
  if (opts?.appName) {
    return { name: opts.appName };
  }
  if (process.env.NX_TASK_TARGET_PROJECT) {
    return { name: process.env.NX_TASK_TARGET_PROJECT };
  }
  try {
    const packageJsonString = import_node_fs6.default.readFileSync(
      import_node_path6.default.join(opts?.packageRoot || ".", "package.json"),
      "utf-8"
    );
    const packageJson = JSON.parse(packageJsonString);
    if (!packageJson.name) {
      throw new MicrofrontendError(
        `package.json file missing required field "name"`,
        {
          type: "packageJson",
          subtype: "missing_field_name",
          source: "@vercel/microfrontends/next"
        }
      );
    }
    return { name: packageJson.name };
  } catch (err) {
    throw MicrofrontendError.handle(err, {
      fileName: "package.json"
    });
  }
}

// src/config/microfrontends/server/utils/get-output-file-path.ts
var import_node_path7 = __toESM(require("path"), 1);

// src/config/microfrontends/server/constants.ts
var MFE_CONFIG_DEFAULT_FILE_PATH = "microfrontends";
var MFE_CONFIG_DEFAULT_FILE_NAME = "microfrontends.json";

// src/config/microfrontends/server/utils/get-output-file-path.ts
function getOutputFilePath() {
  return import_node_path7.default.join(MFE_CONFIG_DEFAULT_FILE_PATH, MFE_CONFIG_DEFAULT_FILE_NAME);
}

// src/config/microfrontends/server/validation.ts
var import_jsonc_parser3 = require("jsonc-parser");
var import_ajv = require("ajv");

// schema/schema.json
var schema_default = {
  $schema: "http://json-schema.org/draft-07/schema#",
  $ref: "#/definitions/Config",
  definitions: {
    Config: {
      type: "object",
      properties: {
        $schema: {
          type: "string"
        },
        version: {
          type: "string",
          const: "1"
        },
        options: {
          $ref: "#/definitions/Options"
        },
        applications: {
          $ref: "#/definitions/ApplicationRouting",
          description: "Mapping of application names to the routes that they host. Only needs to be defined in the application that owns the primary microfrontend domain"
        }
      },
      required: ["applications"],
      additionalProperties: false
    },
    Options: {
      type: "object",
      properties: {
        disableOverrides: {
          type: "boolean",
          description: "If you want to disable the overrides for the site. For example, if you are managing rewrites between applications externally, you may wish to disable the overrides on the toolbar as they will have no effect."
        },
        localProxyPort: {
          type: "number",
          description: "The port number used by the local proxy server.\n\nThe default is `3024`."
        }
      },
      additionalProperties: false
    },
    ApplicationRouting: {
      type: "object",
      additionalProperties: {
        $ref: "#/definitions/Application"
      },
      propertyNames: {
        description: "The unique identifier for a Microfrontend Application.\n\nMust match the Vercel project name.\n\nNote: If this name does not also match the name used to run the application, (e.g. the `name` from the `package.json`), then the `packageName` field should be set."
      }
    },
    Application: {
      anyOf: [
        {
          $ref: "#/definitions/DefaultApplication"
        },
        {
          $ref: "#/definitions/ChildApplication"
        }
      ]
    },
    DefaultApplication: {
      type: "object",
      properties: {
        projectId: {
          type: "string",
          description: "Vercel project ID, only required if the application name / id is different to the Vercel project name.",
          deprecated: "Instead, the application id should match the Vercel project name. `packageName` can optionally\nbe set to the name of the package.json (if it is different from the project name)."
        },
        packageName: {
          type: "string",
          description: "The name used to run the application, e.g. the `name` field in the `package.json`.\n\nThis is used by the local proxy to map the application config to the locally running app.\n\nThis is only necessary when the application name does not match the `name` used in `package.json`."
        },
        development: {
          $ref: "#/definitions/DefaultDevelopment",
          description: "Development configuration for the default application."
        }
      },
      required: ["development"],
      additionalProperties: false
    },
    DefaultDevelopment: {
      type: "object",
      properties: {
        local: {
          type: ["number", "string"],
          description: "A local port number or host string that this application runs on when it is running locally. If passing a string, include the protocol (optional), host (required) and port (optional). For example: `https://this.ismyhost:8080`. If omitted, the protocol defaults to HTTP. If omitted, the port defaults to a unique, but stable (based on the application name) number.\n\nExamples of valid values:\n- 8080\n- my.localhost.me\n- my.localhost.me:8080\n- https://my.localhost.me\n- https://my.localhost.me:8080"
        },
        localPort: {
          type: "number",
          description: "The local port number that this application runs on when it is running locally. Common values include `80` for HTTP and `443` for HTTPS. If omitted, the port defaults to a unique, but stable (based on the application name) number.",
          deprecated: "Please set the port with the 'local' field instead."
        },
        task: {
          type: "string",
          description: "Optional task to run when starting the development server. Should reference a script in the package.json of the application."
        },
        fallback: {
          type: "string",
          description: "Fallback for local development, could point to any environment. This is required for the default app. This value is used as the fallback for child apps as well if they do not have a fallback.\n\nIf passing a string, include the protocol (optional), host (required) and port (optional). For example: `https://this.ismyhost:8080`. If omitted, the protocol defaults to HTTPS. If omitted, the port defaults to `80` for HTTP and `443` for HTTPS."
        }
      },
      required: ["fallback"],
      additionalProperties: false
    },
    ChildApplication: {
      type: "object",
      properties: {
        projectId: {
          type: "string",
          description: "Vercel project ID, only required if the application name / id is different to the Vercel project name.",
          deprecated: "Instead, the application id should match the Vercel project name. `packageName` can optionally\nbe set to the name of the package.json (if it is different from the project name)."
        },
        packageName: {
          type: "string",
          description: "The name used to run the application, e.g. the `name` field in the `package.json`.\n\nThis is used by the local proxy to map the application config to the locally running app.\n\nThis is only necessary when the application name does not match the `name` used in `package.json`."
        },
        development: {
          $ref: "#/definitions/ChildDevelopment",
          description: "Development configuration for the child application."
        },
        routing: {
          $ref: "#/definitions/Routing",
          description: "Groups of path expressions that are routed to this application."
        }
      },
      required: ["routing"],
      additionalProperties: false
    },
    ChildDevelopment: {
      type: "object",
      properties: {
        local: {
          type: ["number", "string"],
          description: "A local port number or host string that this application runs on when it is running locally. If passing a string, include the protocol (optional), host (required) and port (optional). For example: `https://this.ismyhost:8080`. If omitted, the protocol defaults to HTTP. If omitted, the port defaults to a unique, but stable (based on the application name) number.\n\nExamples of valid values:\n- 8080\n- my.localhost.me\n- my.localhost.me:8080\n- https://my.localhost.me\n- https://my.localhost.me:8080"
        },
        localPort: {
          type: "number",
          description: "The local port number that this application runs on when it is running locally. Common values include `80` for HTTP and `443` for HTTPS. If omitted, the port defaults to a unique, but stable (based on the application name) number.",
          deprecated: "Please set the port with the 'local' field instead."
        },
        task: {
          type: "string",
          description: "Optional task to run when starting the development server. Should reference a script in the package.json of the application."
        },
        fallback: {
          type: "string",
          description: "Fallback for local development, could point to any environment. This is optional for child apps. If not provided, the fallback of the default app will be used.\n\nIf passing a string, include the protocol (optional), host (required) and port (optional). For example: `https://this.ismyhost:8080`. If omitted, the protocol defaults to HTTPS. If omitted, the port defaults to `80` for HTTP and `443` for HTTPS."
        }
      },
      additionalProperties: false
    },
    Routing: {
      type: "array",
      items: {
        $ref: "#/definitions/PathGroup"
      }
    },
    PathGroup: {
      type: "object",
      properties: {
        group: {
          type: "string",
          description: "Optional group name for the paths"
        },
        flag: {
          type: "string",
          description: "flag name that can be used to enable/disable all paths in the group"
        },
        paths: {
          type: "array",
          items: {
            type: "string"
          }
        }
      },
      required: ["paths"],
      additionalProperties: false
    }
  }
};

// src/config/schema/utils/load.ts
var SCHEMA = schema_default;

// src/config/microfrontends/server/validation.ts
var LIST_FORMATTER2 = new Intl.ListFormat("en", {
  style: "long",
  type: "disjunction"
});
function formatAjvErrors(errors) {
  if (!errors) {
    return [];
  }
  const errorMessages = [];
  for (const error of errors) {
    if (error.instancePath === "" && (error.keyword === "anyOf" || error.keyword === "required" && error.params.missingProperty === "partOf")) {
      continue;
    }
    const instancePath = error.instancePath.slice(1);
    const formattedInstancePath = instancePath === "" ? "at the root" : `in field ${instancePath}`;
    if (error.keyword === "required" && error.params.missingProperty === "routing" && instancePath.split("/").length === 2) {
      errorMessages.push(
        `Unable to infer if ${instancePath} is the default app or a child app. This usually means that there is another error in the configuration.`
      );
    } else if (error.keyword === "anyOf" && instancePath.split("/").length > 2) {
      const anyOfErrors = errors.filter(
        (e) => e.instancePath === error.instancePath && e.keyword !== "anyOf"
      );
      if (anyOfErrors.every((e) => e.keyword === "type")) {
        const allowedTypes = LIST_FORMATTER2.format(
          anyOfErrors.map((e) => {
            return e.keyword === "type" ? String(e.params.type) : "unknown";
          })
        );
        errorMessages.push(
          `Incorrect type for ${instancePath}. Must be one of ${allowedTypes}`
        );
      } else {
        errorMessages.push(
          `Invalid field for ${instancePath}. Possible error messages are ${LIST_FORMATTER2.format(anyOfErrors.map((e) => e.message ?? ""))}`
        );
      }
    } else if (error.keyword === "additionalProperties" && !(error.params.additionalProperty === "routing" && instancePath.split("/").length === 2)) {
      errorMessages.push(
        `Property '${error.params.additionalProperty}' is not allowed ${formattedInstancePath}`
      );
    } else if (error.keyword === "required") {
      errorMessages.push(
        `Property '${error.params.missingProperty}' is required ${formattedInstancePath}`
      );
    }
  }
  return errorMessages;
}
function validateSchema(configString) {
  const parsedConfig = (0, import_jsonc_parser3.parse)(configString);
  const ajv = new import_ajv.Ajv({ allowUnionTypes: true });
  const validate = ajv.compile(SCHEMA);
  const isValid = validate(parsedConfig);
  if (!isValid) {
    throw new MicrofrontendError(
      `Invalid microfrontends config:${formatAjvErrors(validate.errors).map((error) => `
 - ${error}`).join(
        ""
      )}

See https://openapi.vercel.sh/microfrontends.json for the schema.`,
      { type: "config", subtype: "does_not_match_schema" }
    );
  }
  return parsedConfig;
}

// src/config/microfrontends/server/index.ts
var MicrofrontendsServer = class {
  constructor({
    config,
    overrides
  }) {
    this.config = new MicrofrontendConfigIsomorphic({ config, overrides });
  }
  /**
   * Writes the configuration to a file.
   */
  writeConfig(opts = {
    pretty: true
  }) {
    const outputPath = getOutputFilePath();
    import_node_fs7.default.mkdirSync((0, import_node_path8.dirname)(outputPath), { recursive: true });
    import_node_fs7.default.writeFileSync(
      outputPath,
      JSON.stringify(
        this.config.toSchemaJson(),
        null,
        opts.pretty ?? true ? 2 : void 0
      )
    );
  }
  // --------- Static Methods ---------
  /**
   * Generates a MicrofrontendsServer instance from an unknown object.
   */
  static fromUnknown({
    config,
    cookies
  }) {
    const overrides = cookies ? parseOverrides(cookies) : void 0;
    if (typeof config === "string") {
      return new MicrofrontendsServer({
        config: MicrofrontendsServer.validate(config),
        overrides
      });
    }
    if (typeof config === "object") {
      return new MicrofrontendsServer({
        config,
        overrides
      });
    }
    throw new MicrofrontendError(
      "Invalid config: must be a string or an object",
      { type: "config", subtype: "does_not_match_schema" }
    );
  }
  /**
   * Generates a MicrofrontendsServer instance from the environment.
   * Uses additional validation that is only available when in a node runtime
   */
  static fromEnv({
    cookies
  }) {
    return new MicrofrontendsServer({
      config: MicrofrontendsServer.validate(getConfigStringFromEnv()),
      overrides: parseOverrides(cookies)
    });
  }
  /**
   * Validates the configuration against the JSON schema
   */
  static validate(config) {
    if (typeof config === "string") {
      const c = validateSchema(config);
      return c;
    }
    return config;
  }
  /**
   * Looks up the configuration by inferring the package root and looking for a microfrontends config file. If a file is not found,
   * it will look for a package in the repository with a microfrontends file that contains the current application
   * and use that configuration.
   *
   * This can return either a Child or Main configuration.
   */
  static infer({
    directory,
    filePath,
    cookies
  } = {}) {
    if (filePath) {
      return MicrofrontendsServer.fromFile({
        filePath,
        cookies
      });
    }
    try {
      const packageRoot = findPackageRoot(directory);
      const { name: appName } = getApplicationContext({ packageRoot });
      const maybeConfig = findConfig({ dir: packageRoot });
      if (maybeConfig) {
        return MicrofrontendsServer.fromFile({
          filePath: maybeConfig,
          cookies
        });
      }
      const repositoryRoot = findRepositoryRoot();
      const isMonorepo2 = isMonorepo({ repositoryRoot });
      if (isMonorepo2) {
        const defaultPackage = findDefaultMicrofrontendsPackage({
          repositoryRoot,
          applicationName: appName
        });
        const maybeConfigFromDefault = findConfig({ dir: defaultPackage });
        if (maybeConfigFromDefault) {
          return MicrofrontendsServer.fromFile({
            filePath: maybeConfigFromDefault,
            cookies
          });
        }
      }
      throw new Error("Unable to infer");
    } catch (e) {
      if (e instanceof MicrofrontendError) {
        throw e;
      }
      throw new MicrofrontendError(
        "Unable to locate and parse microfrontends configuration",
        { cause: e, type: "config", subtype: "inference_failed" }
      );
    }
  }
  /*
   * Generates a MicrofrontendsServer instance from a file.
   */
  static fromFile({
    filePath,
    cookies
  }) {
    try {
      const configJson = import_node_fs7.default.readFileSync(filePath, "utf-8");
      const config = MicrofrontendsServer.validate(configJson);
      return new MicrofrontendsServer({
        config,
        overrides: cookies ? parseOverrides(cookies) : void 0
      });
    } catch (e) {
      throw MicrofrontendError.handle(e, {
        fileName: filePath
      });
    }
  }
  /*
   * Generates a MicrofrontendsServer instance from a file.
   */
  static fromMainConfigFile({
    filePath,
    overrides
  }) {
    try {
      const config = import_node_fs7.default.readFileSync(filePath, "utf-8");
      const validatedConfig = MicrofrontendsServer.validate(config);
      const [defaultApplication] = Object.entries(validatedConfig.applications).filter(([, app]) => isDefaultApp(app)).map(([name]) => name);
      if (!defaultApplication) {
        throw new MicrofrontendError(
          "No default application found. At least one application needs to be the default by omitting routing.",
          { type: "config", subtype: "no_default_application" }
        );
      }
      return new MicrofrontendsServer({
        config: validatedConfig,
        overrides
      });
    } catch (e) {
      throw MicrofrontendError.handle(e, {
        fileName: filePath
      });
    }
  }
};

// src/bin/local-auth.ts
var localAuthHtml = ({
  app,
  hostname,
  defaultApp,
  automationBypassEnvVarName,
  automationBypass
}) => {
  const content = automationBypass ? `<b><code>${automationBypassEnvVarName}</code></b> is set with the value <b><code>${automationBypass}</code></b>, please verify this value equals the <a href="https://vercel.com/docs/deployment-protection/methods-to-bypass-deployment-protection/protection-bypass-automation">Protection Bypass for Automation</a> for the Vercel project hosting the deployment.` : `To access, set a local environment variable <b><code>${automationBypassEnvVarName}</code></b> with the value of the <a href="https://vercel.com/docs/deployment-protection/methods-to-bypass-deployment-protection/protection-bypass-automation">Protection Bypass for Automation</a> for the Vercel project hosting the deployment.`;
  return `<!DOCTYPE html>
	<html lang="en">
	  <head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1">
		<meta name="theme-color" content="#000">
		<title>Authentication Required</title>
		<style>
		  html {
			font-size: 62.5%;
			box-sizing: border-box;
			height: -webkit-fill-available
		  }
	
		  *,
		  ::after,
		  ::before {
			box-sizing: inherit
		  }
	
		  body {
			font-family: "SF Pro Text", "SF Pro Icons", "Helvetica Neue", "Helvetica", "Arial", sans-serif;
			font-size: 1.6rem;
			line-height: 1.65;
			word-break: break-word;
			font-kerning: auto;
			font-variant: normal;
			-webkit-font-smoothing: antialiased;
			-moz-osx-font-smoothing: grayscale;
			text-rendering: optimizeLegibility;
			hyphens: none;
			height: 100vh;
			height: -webkit-fill-available;
			max-height: 100vh;
			max-height: -webkit-fill-available;
			margin: 0
		  }
	
		  ::selection {
			background: #79FFE1;
		  }
		  ::-moz-selection {
			background: #79FFE1;
		  }
	
		  a {
			cursor: pointer;
			color: #0070f3;
			text-decoration: none;
			transition: all .2s ease;
			border-bottom: 1px solid transparent
		  }
	
		  a:hover {
			border-bottom: 1px solid #0070f3
		  }
	
		  ul {
			padding: 0;
			margin-left: 1.5em;
			list-style-type: none
		  }
	
		  li {
			margin-bottom: 10px
		  }
	
		  ul li:before {
			content: '\\02013'
		  }
	
		  li:before {
			display: inline-block;
			color: #ccc;
			position: absolute;
			margin-left: -18px;
			transition: color .2s ease
		  }
	
		  code {
			font-family: Menlo, Monaco, Lucida Console, Liberation Mono, DejaVu Sans Mono, Bitstream Vera Sans Mono, Courier New, monospace, serif;
			font-size: .92em;
		  }
	
		  code:after,
		  code:before {
			content: '\`'
		  }
	
		  .container {
			display: flex;
			justify-content: center;
			flex-direction: column;
			min-height: 100%
		  }
	
		  main {
			max-width: 80rem;
			padding: 4rem 6rem;
			margin: auto
		  }
	
		  ul {
			margin-bottom: 32px
		  }
	
		  .error-title {
			font-size: 2rem;
			padding-left: 22px;
			line-height: 1.5;
			margin-bottom: 24px;
		  }
	
		  .error-title-guilty {
			border-left: 2px solid #ED367F;
		  }
	
		  .error-title-innocent {
			border-left: 2px solid #59B89C;
		  }
	
		  main p {
			color: #333
		  }
	
		  .devinfo-container {
			border: 1px solid #ddd;
			border-radius: 4px;
			padding: 2rem;
			display: flex;
			flex-direction: column;
			margin-bottom: 32px
		  }
	
		  .error-code {
			margin: 0;
			font-size: 1.6rem;
			color: #000;
			margin-bottom: 1.6rem
		  }
	
		  .devinfo-line {
			color: #333
		  }
	
		  .devinfo-line code,
		  code,
		  li {
			color: #000
		  }
	
		  .devinfo-line:not(:last-child) {
			margin-bottom: 8px
		  }
	
		  .docs-link,
		  .contact-link {
			font-weight: 500
		  }
	
		  header,
		  footer,
		  footer a {
			display: flex;
			justify-content: center;
			align-items: center
		  }
	
		  header,
		  footer {
			min-height: 100px;
			height: 100px;
		  }
	
		  header {
			border-bottom: 1px solid #eaeaea;
		  }
	
		  header h1 {
			font-size: 1.8rem;
			margin: 0;
			font-weight: 500;
		  }
	
		  header p {
			font-size: 1.3rem;
			margin: 0;
			font-weight: 500;
		  }
	
		  .header-item {
			display: flex;
			padding: 0 2rem;
			margin: 2rem 0;
			text-decoration: line-through;
			color: #999;
		  }
	
		  .header-item.active {
			color: #ff0080;
			text-decoration: none;
		  }
	
		  .header-item.first {
			border-right: 1px solid #eaeaea;
		  }
	
		  .header-item-content {
			display: flex;
			flex-direction: column;
		  }
	
		  .header-item-icon {
			margin-right: 1rem;
			margin-top: 0.6rem;
		  }
	
		  footer {
			border-top: 1px solid #eaeaea;
		  }
	
		  footer a {
			color: #000
		  }
	
		  footer a:hover {
			border-bottom-color: transparent
		  }
	
		  footer svg {
			margin-left: .8rem
		  }
	
		  .note {
			padding: 8pt 16pt;
			border-radius: 5px;
			border: 1px solid #0070f3;
			font-size: 14px;
			line-height: 1.8;
			color: #0070f3;
		  }
	
		  @media (max-width:500px) {
			.devinfo-container .devinfo-line code {
			  margin-top: .4rem
			}
			.devinfo-container .devinfo-line:not(:last-child) {
			  margin-bottom: 1.6rem
			}
			.devinfo-container {
			  margin-bottom: 0;
			}
			header {
			  flex-direction: column;
			  height: auto;
			  min-height: auto;
			  align-items: flex-start;
			}
			.header-item.first {
			  border-right: none;
			  margin-bottom: 0;
			}
			main {
			  padding: 1rem 2rem;
			}
			body {
			  font-size: 1.4rem;
			  line-height: 1.55;
			}
			footer {
			  display: none;
			}
			.note {
			  margin-top: 16px;
			}
		  }
		</style>
	  </head>
	  <body>
		<div class="container">
		  <main>
			<p class="devinfo-container">
			  <span><b><code>${app}</code></b> is falling back to a protected deployment <a target="_blank" href="https://${hostname}">${hostname}</a>.</span>
        <br>
        <span>${content}</span>
        <br>
        <span>The environment variable should be set in the default app <b><code>${defaultApp}</code></b>, where the local proxy is running.</span>
			</p>
		
			<a href="https://vercel.com/docs/microfrontends/local-development#falling-back-to-protected-deployments"><div class="note">Click here to learn more about setting up the environment variable.</div></a>
		  </main>	
		</div>
	  </body>
	</html>`;
};

// src/bin/local-proxy.ts
var MFE_LOCAL_PROXY_HEADER = "x-vercel-mfe-local-proxy-origin";
var MFE_FLAG_VALUE = "vercel-mfe-flag-value";
var MFE_FLAG_VALUE_HEADER = `x-${MFE_FLAG_VALUE}`;
var MFE_DEBUG = process.env.MFE_DEBUG;
var mfeDebug = (message) => {
  if (MFE_DEBUG === "true" || MFE_DEBUG === "1") {
    console.log(message);
  }
};
var ProxyRequestRouter = class {
  constructor(config, {
    localApps
  }) {
    this.config = config;
    this.localApps = localApps;
  }
  getDefaultHost(config) {
    const defaultApp = config.getDefaultApplication();
    return this.getApplicationTarget(defaultApp);
  }
  getApplicationTarget(application) {
    const useDev = this.localApps.find(
      (name) => name === application.name || name === application.packageName
    );
    let applicationName = application.name;
    let host = useDev ? application.development.local : application.fallback;
    if (application.overrides?.environment?.host) {
      host = application.overrides.environment;
    }
    if (!host) {
      const defaultApp = this.config.getDefaultApplication();
      host = defaultApp.fallback;
      applicationName = defaultApp.name;
    }
    const protocol = host.protocol;
    const hostname = host.host;
    const port = host.port;
    return {
      url: host.toUrl(),
      protocol,
      hostname,
      port,
      application: applicationName
    };
  }
  /**
   * To enable preview deployments in localhost, we need to intercept some auth requests
   * and make sure they proxy to the correct domain. The toolbar will initiate the `vercel-auth-redirect`
   * with a `_host_override` param so that we can properly trigger the redirect flow for the
   * protected host.
   */
  getAuthTarget(request2, config) {
    const url = new import_node_url.URL(request2.url ?? "", `http://${request2.headers.host}`);
    const isAuthRedirect = request2.url?.startsWith(
      "/.well-known/vercel-auth-redirect"
    );
    const isSsoRedirect = request2.url?.startsWith("/sso-api");
    const isJWTRedirect = url.searchParams.has("_vercel_jwt");
    const defaultHost = this.getDefaultHost(config);
    let hostname = null;
    let path7 = request2.url;
    if (isAuthRedirect) {
      hostname = url.searchParams.get("_host_override");
    }
    if (isSsoRedirect) {
      hostname = "vercel.com";
    }
    if (isJWTRedirect) {
      hostname = url.searchParams.get("_host_override");
      url.searchParams.delete("_host_override");
      path7 = `${url.pathname}${url.search}`;
    }
    if (!hostname) {
      return void 0;
    }
    return { ...defaultHost, path: path7, hostname, protocol: "https", port: 443 };
  }
  getConfigWithOverrides(cookies) {
    const cookieOverrides = parseOverrides(
      Object.entries(cookies).map(([name, value]) => ({ name, value }))
    );
    const hasOverrides = Object.keys(cookieOverrides.applications).length > 0;
    const serialized = this.config.serialize().config;
    return hasOverrides ? new MicrofrontendConfigIsomorphic({
      config: serialized,
      overrides: cookieOverrides
    }) : this.config;
  }
  getTarget(request2) {
    const cookies = (0, import_cookie.parse)(request2.headers.cookie || "");
    const config = this.getConfigWithOverrides(cookies);
    if (!request2.url) {
      return this.getDefaultHost(config);
    }
    const { path: path7, mfeFlagValue } = extractMfeFlagValue(request2.url);
    const authTarget = this.getAuthTarget(request2, config);
    if (authTarget) {
      return authTarget;
    }
    const url = new import_node_url.URL(`http://example.com${path7}`);
    const target = this.findMatchingApplication({
      path: path7,
      url,
      applications: config.getChildApplications(),
      referer: request2.headers.referer,
      // If a request already has the local proxy header, then the request has
      // already gone through the local proxy.
      // This should only happen if middleware indicates that a flagged route
      // is enabled, so we treat this as enabling all flagged routes for this request.
      middlewareMfeZone: request2.headers["x-vercel-mfe-zone"],
      // Value to use when encountering any flagged paths instead of checking middleware
      mfeFlagValue
    });
    if (target)
      return target;
    const defaultHost = this.getDefaultHost(config);
    mfeDebug(
      `no matching routes, routing ${path7} to default application: ${JSON.stringify(defaultHost)}`
    );
    return { path: path7, ...defaultHost };
  }
  findMatchingApplication({
    path: path7,
    url,
    applications,
    referer = void 0,
    middlewareMfeZone = void 0,
    mfeFlagValue = void 0
  }) {
    for (const application of Object.values(applications)) {
      const target = this.getApplicationTarget(application);
      if (middlewareMfeZone) {
        if (middlewareMfeZone === application.name) {
          mfeDebug(
            `routing ${path7} to '${target.application}' at ${target.hostname} according to 'x-vercel-mfe-zone' header`
          );
          return { path: path7, ...target };
        }
        continue;
      }
      const builtInRewrite = this.checkBuiltinAssetPrefix({
        rewrites: ["/:path*"],
        path: path7,
        url,
        app: application
      }) || this.checkNextOriginalFrame({ url, referer, applications });
      if (builtInRewrite) {
        return builtInRewrite;
      }
      for (const group of application.routing) {
        for (const childPath of group.paths) {
          const regexp = (0, import_path_to_regexp3.pathToRegexp)(childPath);
          if (regexp.test(url.pathname)) {
            mfeDebug(
              `routing ${path7} to '${target.application}' at ${target.hostname}`
            );
            if (group.flag) {
              if (mfeFlagValue === true) {
              } else if (mfeFlagValue === false) {
                continue;
              } else {
                mfeDebug(
                  "Routing group is behind flag. Routing to default app to check flag via middleware."
                );
                if (!this.isDefaultAppLocal()) {
                  const defaultApp = this.getDefaultHost(this.config);
                  console.error(
                    `'${path7}' is a flagged path, but the default application is not running locally. Using '${defaultApp.hostname}' to handle this request.`
                  );
                }
                return null;
              }
            }
            return { path: path7, ...target };
          }
        }
      }
    }
    if (middlewareMfeZone) {
      console.error(
        `A request contained 'x-vercel-mfe-zone: ${middlewareMfeZone}', but no application was found with that name.`
      );
    }
    return null;
  }
  checkBuiltinAssetPrefix({
    rewrites,
    path: path7,
    url,
    app
  }) {
    const pathname = url.pathname;
    const target = this.getApplicationTarget(app);
    for (const rewrite of rewrites) {
      if ((0, import_path_to_regexp3.pathToRegexp)(`/${app.getAssetPrefix()}${rewrite}`).test(pathname)) {
        mfeDebug(
          `routing ${pathname} to '${target.application}' at ${target.hostname}`
        );
        return {
          path: path7,
          ...target
        };
      }
    }
    return null;
  }
  checkNextOriginalFrame({
    url,
    referer = void 0,
    applications
  }) {
    const isStackFrame = (0, import_path_to_regexp3.pathToRegexp)("/__nextjs_original-stack-frame").test(url.pathname) || // Plural form was introduced in https://github.com/vercel/next.js/pull/75557
    (0, import_path_to_regexp3.pathToRegexp)("/__nextjs_original-stack-frames").test(url.pathname);
    if (!referer || !isStackFrame) {
      return null;
    }
    const refererURL = new import_node_url.URL(referer);
    const refererPath = `${refererURL.pathname}?${refererURL.search}`;
    const refererApp = this.findMatchingApplication({
      path: refererPath,
      url: refererURL,
      applications
    });
    mfeDebug(
      `routing nextjs stack frame request to ${refererApp?.application}`
    );
    return refererApp ? {
      ...refererApp,
      path: `${url.pathname}${url.search}`
    } : null;
  }
  isDefaultAppLocal() {
    const defaultApp = this.config.getDefaultApplication();
    return Boolean(
      this.localApps.find(
        (name) => name === defaultApp.name || name === defaultApp.packageName
      )
    );
  }
};
var LocalProxy = class {
  constructor(config, {
    localApps,
    proxyPort
  }) {
    this.router = new ProxyRequestRouter(config, { localApps });
    this.proxyPort = proxyPort ?? this.router.config.getLocalProxyPort();
    this.proxy = import_http_proxy.default.createProxyServer({ secure: true });
    this.proxy.on("error", (err, req, res) => {
      if (res instanceof http.ServerResponse) {
        res.writeHead(500, {
          "Content-Type": "text/plain"
        });
      }
      const target = this.router.getTarget(req);
      res.end(
        `Error proxying request to ${target.application}. Is the server running locally on port ${target.port}?`
      );
      console.error(`Error proxying request for ${target.application}: `, err);
    });
  }
  static fromFile(filePath, {
    localApps,
    proxyPort
  }) {
    let microfrontends;
    if (filePath) {
      microfrontends = MicrofrontendsServer.fromFile({
        filePath
      });
    } else {
      microfrontends = MicrofrontendsServer.infer();
    }
    LocalProxy.validateLocalApps(localApps, microfrontends.config);
    return new LocalProxy(microfrontends.config, { localApps, proxyPort });
  }
  static validateLocalApps(localApps, config) {
    const unknownApps = [];
    const allApps = /* @__PURE__ */ new Set();
    for (const app of config.getAllApplications()) {
      allApps.add(app.name);
    }
    for (const app of localApps) {
      if (!allApps.has(app)) {
        unknownApps.push(app);
      }
    }
    if (unknownApps.length) {
      throw new Error(
        `The following apps passed via --local-apps are not in the microfrontends config: ${unknownApps.join(", ")} (microfrontends config contains: ${Array.from(allApps).join(", ")})`
      );
    }
  }
  startServer() {
    const httpServer = http.createServer(
      (req, res) => this.handleRequest(req, res)
    );
    httpServer.on("upgrade", (req, socket, head) => {
      const target = this.router.getTarget(req);
      try {
        const headers = {};
        headers[MFE_LOCAL_PROXY_HEADER] = "1";
        this.proxy.ws(req, socket, head, {
          target: target.url,
          headers
        });
      } catch (err) {
        console.error("Error proxying ws: ", err);
      }
    });
    httpServer.listen(this.proxyPort, () => {
      console.log(`Microfrontends Proxy: http://localhost:${this.proxyPort}`);
    });
  }
  handleRequest(req, res) {
    if (this.handleProxyInfoRequest(req.url, res)) {
      return;
    }
    const target = this.router.getTarget(req);
    const { req: strippedReq, mfeFlagValue } = removeMfeFlagQuery(req);
    if (target.protocol === "https") {
      const { hostname, port, path: path7 } = target;
      const app = this.router.config.getApplication(target.application);
      const automationBypass = process.env[app.getAutomationBypassEnvVarName()];
      const requestOptions = {
        hostname,
        path: path7,
        method: req.method,
        headers: {
          ...req.headers,
          host: hostname,
          ...automationBypass ? { "x-vercel-protection-bypass": automationBypass } : {}
        },
        port
      };
      const localhost = `http://localhost:${this.proxyPort}`;
      const proxyReq = https.request(requestOptions, (realRes) => {
        if (realRes.statusCode === 401 && realRes.headers["set-cookie"]?.find(
          (cookie) => cookie.startsWith("_vercel_sso_nonce=")
        )) {
          const defaultApp = this.router.config.getDefaultApplication();
          return res.end(
            localAuthHtml({
              app: target.application,
              hostname,
              defaultApp: defaultApp.packageName || defaultApp.name,
              automationBypassEnvVarName: app.getAutomationBypassEnvVarName(),
              automationBypass
            })
          );
        }
        if (realRes.statusCode === 307) {
          const locationHeader = realRes.headers.location;
          if (locationHeader) {
            const redirectUrl = new import_node_url.URL(
              locationHeader.replace(/https:\/\/[^/]+\//, "/"),
              localhost
            );
            realRes.headers.location = redirectUrl.toString();
          }
        }
        res.writeHead(realRes.statusCode || 200, realRes.headers);
        realRes.pipe(res, { end: true });
      });
      req.pipe(proxyReq);
      proxyReq.on("error", (err) => {
        console.error("Proxy request error: ", err);
        res.writeHead(500, { "Content-Type": "text/plain" });
        res.end(
          `Error proxying request for ${target.application} to ${hostname}:${port}${path7}`
        );
      });
    } else {
      const headers = {};
      headers[MFE_LOCAL_PROXY_HEADER] = "1";
      if (mfeFlagValue !== void 0) {
        headers[MFE_FLAG_VALUE_HEADER] = mfeFlagValue.toString();
      }
      this.proxy.web(strippedReq, res, {
        target: target.url,
        headers
      });
    }
  }
  // Handles requests that return data from the local proxy itself.
  // Returns true if the request was handled, false otherwise.
  handleProxyInfoRequest(path7, res) {
    if (!path7) {
      return false;
    }
    const url = new import_node_url.URL(`http://example.comf${path7}`);
    const pathname = url.pathname;
    switch (pathname) {
      case "/.well-known/vercel/microfrontends/routing": {
        res.writeHead(200, {
          "Content-Type": "application/json"
        });
        const payload = Object.fromEntries(
          this.router.config.getAllApplications().map((app) => {
            const { hostname, port, protocol } = this.router.getApplicationTarget(app);
            return [
              app.name,
              { routing: { host: hostname, port, protocol } }
            ];
          })
        );
        res.end(JSON.stringify(payload));
        return true;
      }
    }
    return false;
  }
};
function extractMfeFlagValue(path7) {
  const host = "http://example.com";
  const url = new import_node_url.URL(`${host}${path7}`);
  const mfeFlagValue = stringAsBoolean(url.searchParams.get(MFE_FLAG_VALUE));
  url.searchParams.delete(MFE_FLAG_VALUE);
  const pathWithoutMfe = mfeFlagValue === void 0 ? path7 : url.toString().substring(host.length);
  return { path: pathWithoutMfe, mfeFlagValue };
}
function stringAsBoolean(value) {
  if (value === "true") {
    return true;
  }
  if (value === "false") {
    return false;
  }
  return void 0;
}
function removeMfeFlagQuery(req) {
  if (!req.url) {
    return { req };
  }
  const { path: path7, mfeFlagValue } = extractMfeFlagValue(req.url);
  if (mfeFlagValue === void 0) {
    return { req };
  }
  req.url = path7;
  return { req, mfeFlagValue };
}

// src/bin/port.ts
var import_node_process = require("process");

// src/utils/mfe-port.ts
var import_node_path9 = __toESM(require("path"), 1);
var import_node_fs8 = __toESM(require("fs"), 1);
function mfePort(packageDir) {
  const { name: appName, version } = getPackageJson(packageDir);
  const result = loadConfig({ packageDir, appName });
  if (!result) {
    throw new MicrofrontendError(
      `Unable to determine configured port for ${appName}`,
      { type: "config", subtype: "not_found" }
    );
  }
  const { port } = result;
  return {
    name: appName,
    version,
    port
  };
}
function getPackageJson(packageDir) {
  const filePath = import_node_path9.default.join(packageDir, "package.json");
  return JSON.parse(import_node_fs8.default.readFileSync(filePath, "utf-8"));
}
function loadConfig({
  packageDir,
  appName
}) {
  let config;
  try {
    config = MicrofrontendsServer.infer({
      directory: packageDir
    });
  } catch (e) {
    return void 0;
  }
  const app = config.config.getApplication(appName);
  const port = app.development.local.port ?? (app.development.local.protocol === "https" ? 443 : 80);
  return { port };
}

// src/bin/port.ts
function displayPort() {
  const portInfo = mfePort((0, import_node_process.cwd)());
  header(portInfo);
  console.log(portInfo.port);
}
function header({ name, version, port }) {
  console.error(`
  \u25B2 ${name}@${version}
    \xB7 setting port to ${port}
  `);
}

// src/bin/index.ts
function main() {
  (0, import_env.loadEnvConfig)(process.cwd());
  const program = new import_commander.Command();
  program.name(package_default.name).description("Tools for working with micro-frontend applications").version(package_default.version, "-v, --version", "output the current version");
  program.command("proxy").argument("[filePath]", "Path to the micro-frontend configuration file").option(
    "--local-apps <names...>",
    "List of locally running applications",
    []
  ).addOption(new import_commander.Option("--names <names...>").hideHelp()).option("--port <port>", "Port proxy will use", (value) => {
    const parsedValue = Number.parseInt(value, 10);
    if (isNaN(parsedValue) || parsedValue <= 0) {
      throw new Error("Port must be a positive number");
    }
    return parsedValue;
  }).action((filePath, options) => {
    if (options.names && options.localApps.length) {
      throw new Error(
        "Both --names and --local-apps are set. --names is deprecated and has been replaced with --local-apps, which functions exactly the same. Please only set --local-apps."
      );
    }
    const localProxy = LocalProxy.fromFile(filePath, {
      localApps: options.names ?? options.localApps,
      proxyPort: options.port
    });
    localProxy.startServer();
  });
  program.command("port").description("Prints development port").action(() => {
    displayPort();
  });
  program.parse(process.argv);
}
main();
