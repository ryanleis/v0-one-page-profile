{"version":3,"sources":["../../src/next/client/link/microfrontends-link.tsx","../../src/config/react/use-client-config.ts","../../src/config/microfrontends-config/client/index.ts","../../src/next/client/prefetch/prefetch-cross-zone-links-context.tsx","../../src/next/client/prefetch/prefetch-cross-zone-links.tsx","../../src/next/client/image/microfrontends-image.tsx","../../src/config/microfrontends-config/isomorphic/utils/generate-asset-prefix.ts"],"sourcesContent":["import type { AnchorHTMLAttributes } from 'react';\nimport { forwardRef, useContext } from 'react';\nimport NextLink, { type LinkProps as NextLinkProps } from 'next/link.js';\nimport { useClientConfig } from '../../../config/react/use-client-config';\nimport { PrefetchCrossZoneLinksContext } from '../prefetch';\n\ninterface BaseProps {\n  children: React.ReactNode;\n  href: string;\n}\nexport type LinkProps = BaseProps &\n  Omit<NextLinkProps, keyof BaseProps> &\n  Omit<AnchorHTMLAttributes<HTMLAnchorElement>, keyof BaseProps>;\n\nconst CURRENT_ZONE = process.env.NEXT_PUBLIC_MFE_CURRENT_APPLICATION;\n\nexport function useZoneForHref(href: LinkProps['href'] | undefined): {\n  zoneOfHref: string | null;\n  isDifferentZone: boolean;\n  isLoading: boolean;\n} {\n  const { clientConfig, isLoading } = useClientConfig(\n    process.env.NEXT_PUBLIC_MFE_CLIENT_CONFIG,\n    {\n      removeFlaggedPathsFromDefault: true,\n    },\n  );\n  const isRelativePath = typeof href === 'string' && href.startsWith('/');\n  const zoneOfHref = isRelativePath\n    ? clientConfig.getApplicationNameForPath(href)\n    : null;\n  if (typeof href === 'string' && !href.length) {\n    return {\n      zoneOfHref: null,\n      isDifferentZone: false,\n      isLoading: false,\n    };\n  }\n  const isDifferentZone =\n    !isRelativePath || (zoneOfHref ? CURRENT_ZONE !== zoneOfHref : false);\n  return { zoneOfHref, isDifferentZone, isLoading };\n}\n\n/**\n * A Link component that works with microfrontend set-ups and will prefetch the\n * cross zone links automatically.\n */\nexport const Link = forwardRef<HTMLAnchorElement, LinkProps>(\n  ({ children, ...props }, ref): JSX.Element => {\n    const { prefetchHref } = useContext(PrefetchCrossZoneLinksContext);\n    const { zoneOfHref, isDifferentZone, isLoading } = useZoneForHref(\n      props.href,\n    );\n\n    function onHoverPrefetch(): void {\n      if (!props.href) {\n        return;\n      }\n      prefetchHref(props.href);\n    }\n\n    if (isDifferentZone && zoneOfHref !== null) {\n      const { prefetch: _, ...rest } = props;\n      return (\n        <a\n          {...rest}\n          data-zone={zoneOfHref}\n          onFocus={props.prefetch !== false ? onHoverPrefetch : undefined}\n          onMouseOver={props.prefetch !== false ? onHoverPrefetch : undefined}\n        >\n          {children}\n        </a>\n      );\n    }\n\n    return (\n      <NextLink\n        {...props}\n        data-zone={!zoneOfHref ? 'null' : 'same'}\n        prefetch={props.prefetch ?? (isLoading ? false : undefined)}\n        ref={ref}\n      >\n        {children}\n      </NextLink>\n    );\n  },\n);\nLink.displayName = 'MicrofrontendsLink';\n","'use client';\n\nimport { useState, useEffect } from 'react';\nimport type { WellKnownClientData } from '../well-known/types';\nimport { MicrofrontendConfigClient } from '../microfrontends-config/client';\n\nlet cachedServerClientConfigPromise: Promise<MicrofrontendConfigClient | null> | null =\n  null;\n\nasync function fetchClientConfigFromServer(): Promise<MicrofrontendConfigClient | null> {\n  try {\n    const response = await fetch(\n      '/.well-known/vercel/microfrontends/client-config',\n    );\n    if (response.status !== 200) {\n      return null;\n    }\n    const responseJson = (await response.json()) as WellKnownClientData;\n    return new MicrofrontendConfigClient(responseJson.config);\n  } catch (err) {\n    return null;\n  }\n}\n\n/**\n * Hook to use the client microfrontends configuration. This hook will resolve\n * dynamic paths by fetching the configuration from the server if necessary,\n * allowing the server to specify the values for dynamic paths.\n */\nexport function useClientConfig(\n  config: string | undefined,\n  {\n    removeFlaggedPathsFromDefault,\n  }: {\n    removeFlaggedPathsFromDefault?: boolean;\n  } = {},\n): {\n  clientConfig: MicrofrontendConfigClient;\n  isLoading: boolean;\n} {\n  const [clientConfig, setClientConfig] = useState<MicrofrontendConfigClient>(\n    MicrofrontendConfigClient.fromEnv(config, {\n      removeFlaggedPaths: removeFlaggedPathsFromDefault,\n    }),\n  );\n  const [isLoading, setIsLoading] = useState(true);\n  useEffect(() => {\n    if (\n      process.env.NODE_ENV === 'test' &&\n      process.env.MFE_FORCE_CLIENT_CONFIG_FROM_SERVER !== '1'\n    ) {\n      setIsLoading(false);\n      return;\n    }\n    // Since we may remove flagged paths from the client config above, we need\n    // to use the original client config to determine if the config has any\n    // dynamic paths.\n    const originalClientConfig = MicrofrontendConfigClient.fromEnv(config);\n    // As an optimization, only fetch the config from the server if the\n    // microfrontends configuration has any dynamic paths. If it doesn't,\n    // then the server won't return any different values.\n    const hasDynamicPaths = Object.values(\n      originalClientConfig.applications,\n    ).some((app) => app.routing?.some((group) => group.flag));\n    if (!hasDynamicPaths) {\n      setIsLoading(false);\n      return;\n    }\n    if (!cachedServerClientConfigPromise) {\n      cachedServerClientConfigPromise = fetchClientConfigFromServer();\n    }\n    void cachedServerClientConfigPromise\n      .then((newConfig) => {\n        if (newConfig) {\n          setClientConfig((prevConfig) => {\n            return prevConfig.isEqual(newConfig) ? prevConfig : newConfig;\n          });\n        }\n      })\n      .finally(() => {\n        setIsLoading(false);\n      });\n  }, [config, clientConfig.applications]);\n\n  return { clientConfig, isLoading };\n}\n\nexport function resetCachedServerClientConfigPromise(): void {\n  cachedServerClientConfigPromise = null;\n}\n","import { pathToRegexp } from 'path-to-regexp';\nimport type { ClientConfig } from './types';\n\ninterface MicrofrontendConfigClientOptions {\n  removeFlaggedPaths?: boolean;\n}\n\nexport class MicrofrontendConfigClient {\n  applications: ClientConfig['applications'];\n  pathCache: Record<string, string> = {};\n  private readonly serialized: ClientConfig;\n\n  constructor(config: ClientConfig, opts?: MicrofrontendConfigClientOptions) {\n    this.serialized = config;\n    if (opts?.removeFlaggedPaths) {\n      for (const app of Object.values(config.applications)) {\n        if (app.routing) {\n          app.routing = app.routing.filter((match) => !match.flag);\n        }\n      }\n    }\n    this.applications = config.applications;\n  }\n\n  /**\n   * Create a new `MicrofrontendConfigClient` from a JSON string.\n   * Config must be passed in to remain framework agnostic\n   */\n  static fromEnv(\n    config: string | undefined,\n    opts?: MicrofrontendConfigClientOptions,\n  ): MicrofrontendConfigClient {\n    if (!config) {\n      throw new Error('No microfrontends configuration found');\n    }\n    return new MicrofrontendConfigClient(\n      JSON.parse(config) as ClientConfig,\n      opts,\n    );\n  }\n\n  isEqual(other: MicrofrontendConfigClient): boolean {\n    return (\n      JSON.stringify(this.applications) === JSON.stringify(other.applications)\n    );\n  }\n\n  getApplicationNameForPath(path: string): string | null {\n    if (!path.startsWith('/')) {\n      throw new Error(`Path must start with a /`);\n    }\n\n    if (this.pathCache[path]) {\n      return this.pathCache[path];\n    }\n\n    const pathname = new URL(path, 'https://example.com').pathname;\n    for (const [name, application] of Object.entries(this.applications)) {\n      if (application.routing) {\n        for (const group of application.routing) {\n          for (const childPath of group.paths) {\n            const regexp = pathToRegexp(childPath);\n            if (regexp.test(pathname)) {\n              this.pathCache[path] = name;\n              return name;\n            }\n          }\n        }\n      }\n    }\n    const defaultApplication = Object.entries(this.applications).find(\n      ([, application]) => application.default,\n    );\n    if (!defaultApplication) {\n      return null;\n    }\n\n    this.pathCache[path] = defaultApplication[0];\n    return defaultApplication[0];\n  }\n\n  serialize(): ClientConfig {\n    return this.serialized;\n  }\n}\n","import React, {\n  createContext,\n  useCallback,\n  useEffect,\n  useMemo,\n  useState,\n} from 'react';\n\nexport interface PrefetchCrossZoneLinksContext {\n  prefetchHref: (href: string) => void;\n}\n\nexport const PrefetchCrossZoneLinksContext =\n  createContext<PrefetchCrossZoneLinksContext>({\n    // eslint-disable-next-line @typescript-eslint/no-empty-function\n    prefetchHref: () => {},\n  });\n\nexport function PrefetchCrossZoneLinksProvider({\n  children,\n}: {\n  children: React.ReactNode;\n}): JSX.Element | null {\n  const [seenHrefs, setSeenHrefs] = useState(new Set<string>());\n  const [isSafariOrFirefox, setIsSafariOrFirefox] = useState(false);\n\n  useEffect(() => {\n    setIsSafariOrFirefox(\n      typeof navigator !== 'undefined' &&\n        (navigator.userAgent.includes('Firefox') ||\n          (navigator.userAgent.includes('Safari') &&\n            !navigator.userAgent.includes('Chrome'))),\n    );\n  }, []);\n\n  const prefetchHref = useCallback(\n    (href: string): void => {\n      if (!seenHrefs.has(href)) {\n        setSeenHrefs(new Set(seenHrefs).add(href));\n      }\n    },\n    [seenHrefs],\n  );\n\n  const value = useMemo(() => ({ prefetchHref }), [prefetchHref]);\n\n  if (!isSafariOrFirefox) {\n    return <>{children}</>;\n  }\n\n  return (\n    <PrefetchCrossZoneLinksContext.Provider value={value}>\n      {children}\n      {[...seenHrefs].map((href) => (\n        <link as=\"fetch\" href={href} key={href} rel=\"preload\" />\n      ))}\n    </PrefetchCrossZoneLinksContext.Provider>\n  );\n}\n","import { useEffect, useState } from 'react';\nimport Script from 'next/script.js';\nimport { useClientConfig } from '../../../config/react/use-client-config';\n\nconst PREFETCH_ATTR = 'data-prefetch';\nconst DATA_ATTR_SELECTORS = {\n  anyZone: '[data-zone]',\n  external: '[data-zone=\"null\"]',\n  sameZone: '[data-zone=\"same\"]',\n  prefetch: `[${PREFETCH_ATTR}]`,\n} as const;\n\nconst PREFETCH_ON_HOVER_PREDICATES = {\n  and: [\n    { href_matches: '/*' },\n    { selector_matches: DATA_ATTR_SELECTORS.anyZone },\n    { not: { selector_matches: DATA_ATTR_SELECTORS.sameZone } },\n    { not: { selector_matches: DATA_ATTR_SELECTORS.external } },\n  ],\n};\n\nconst PREFETCH_WHEN_VISIBLE_PREDICATES = {\n  and: [\n    { href_matches: '/*' },\n    { selector_matches: DATA_ATTR_SELECTORS.anyZone },\n    { not: { selector_matches: DATA_ATTR_SELECTORS.sameZone } },\n    { not: { selector_matches: DATA_ATTR_SELECTORS.external } },\n    { selector_matches: DATA_ATTR_SELECTORS.prefetch },\n  ],\n};\n\nfunction checkVisibility(element: Element | null): boolean {\n  if (!element) return true;\n\n  if ('checkVisibility' in element) {\n    return element.checkVisibility({ opacityProperty: true });\n  }\n\n  // hack to get around TS thinking element is never;\n  const el = element as Element;\n  const style = window.getComputedStyle(el);\n\n  if (\n    style.display === 'none' ||\n    style.visibility === 'hidden' ||\n    style.opacity === '0'\n  ) {\n    return false;\n  }\n\n  return checkVisibility(el.parentElement);\n}\n\nexport function PrefetchCrossZoneLinks(): JSX.Element | null {\n  const { isLoading } = useClientConfig(\n    process.env.NEXT_PUBLIC_MFE_CLIENT_CONFIG,\n  );\n  const [links, setLinks] = useState<HTMLAnchorElement[]>([]);\n\n  useEffect(() => {\n    if (isLoading) {\n      return;\n    }\n\n    /**\n     * Intersection observer to add the data-prefetch attribute to cross-zone\n     * links that have yet to be prefetched and are visible.\n     */\n    const observer = new IntersectionObserver(\n      (entries) => {\n        entries.forEach((entry) => {\n          if (\n            entry.isIntersecting &&\n            !entry.target.hasAttribute(PREFETCH_ATTR) &&\n            // lazy perform the visibility check for nodes that are intersecting the viewport\n            // and have not been prefetched.\n            checkVisibility(entry.target)\n          ) {\n            entry.target.setAttribute(PREFETCH_ATTR, 'true');\n          }\n        });\n      },\n      {\n        root: null,\n        rootMargin: '0px',\n        threshold: 0.1,\n      },\n    );\n\n    links.forEach((link) => observer.observe(link));\n\n    return () => {\n      observer.disconnect();\n    };\n  }, [isLoading, links]);\n\n  useEffect(() => {\n    if (isLoading) {\n      return;\n    }\n\n    /**\n     * Mutation observer to notify when new nodes have entered/exited the document\n     * or an href has changed.\n     */\n    const observer = new MutationObserver((mutations) => {\n      const hasChanged = mutations.some((mutation) => {\n        return (\n          (mutation.type === 'childList' && mutation.addedNodes.length > 0) ||\n          (mutation.type === 'attributes' && mutation.attributeName === 'href')\n        );\n      });\n\n      if (hasChanged) {\n        // Whenever there's a change, add all cross-zone links that haven't been\n        // prefetched.\n        setLinks(\n          Array.from(\n            document.querySelectorAll<HTMLAnchorElement>(\n              `a${DATA_ATTR_SELECTORS.anyZone}:not(${DATA_ATTR_SELECTORS.prefetch}):not(${DATA_ATTR_SELECTORS.sameZone}):not(${DATA_ATTR_SELECTORS.external})`,\n            ),\n          ),\n        );\n      }\n    });\n\n    observer.observe(document.body, {\n      childList: true,\n      subtree: true,\n      attributes: true,\n      attributeFilter: ['href'],\n    });\n\n    return () => {\n      observer.disconnect();\n    };\n  }, [isLoading]);\n\n  // Wait till the zone-config loads to take into consideration any\n  // flagged routes.\n  if (isLoading) {\n    return null;\n  }\n\n  // Prefetch links with moderate eagerness by default, immediately when marked \"data-prefetch\".\n  // Prerender links with conservative eagerness by default, immediately when marked \"data-prefetch\".\n  const speculationRules = {\n    prefetch: [\n      {\n        eagerness: 'moderate',\n        where: PREFETCH_ON_HOVER_PREDICATES,\n      },\n      {\n        eagerness: 'immediate',\n        where: PREFETCH_WHEN_VISIBLE_PREDICATES,\n      },\n    ],\n    prerender: [\n      {\n        eagerness: 'conservative',\n        where: PREFETCH_ON_HOVER_PREDICATES,\n      },\n    ],\n  };\n\n  return (\n    <Script\n      dangerouslySetInnerHTML={{\n        __html: JSON.stringify(speculationRules),\n      }}\n      id=\"prefetch-zones-links\"\n      type=\"speculationrules\"\n    />\n  );\n}\n","import { forwardRef } from 'react';\n// There is a bug when compiling in Pages Router that accessing the default export\n// from next/image.js causes a \"Element type is invalid\" error in React. :shrug:\nimport { Image as NextImage } from 'next/dist/client/image-component.js';\nimport { getImageProps, type ImageLoader } from 'next/image.js';\nimport { useClientConfig } from '../../../config/react/use-client-config';\nimport { generateAssetPrefixFromName } from '../../../config/microfrontends-config/isomorphic/utils/generate-asset-prefix';\n\nconst CURRENT_ZONE = process.env.NEXT_PUBLIC_MFE_CURRENT_APPLICATION;\n\nconst loaderWithAssetPrefix =\n  (assetPrefix: string, src: string): ImageLoader =>\n  () =>\n    `/${assetPrefix}${src}`;\n\n/**\n * A Image component that prefixes microfrontend child zones with the asset prefix\n * to ensure the image request is routed to the correct zone.\n */\nexport const Image: typeof NextImage = forwardRef(\n  ({ ...props }, ref): JSX.Element => {\n    const { clientConfig } = useClientConfig(\n      process.env.NEXT_PUBLIC_MFE_CLIENT_CONFIG,\n    );\n\n    const assetPrefix =\n      CURRENT_ZONE && !clientConfig.applications[CURRENT_ZONE]?.default\n        ? generateAssetPrefixFromName({ name: CURRENT_ZONE })\n        : null;\n\n    const {\n      props: { src },\n    } = getImageProps(props);\n\n    return (\n      <NextImage\n        loader={\n          assetPrefix ? loaderWithAssetPrefix(assetPrefix, src) : undefined\n        }\n        {...props}\n        ref={ref}\n      />\n    );\n  },\n);\nImage.displayName = 'MicrofrontendsImage';\n","const PREFIX = 'vc-ap';\n\nexport function generateAssetPrefixFromName({\n  name,\n}: {\n  name: string;\n}): string {\n  if (!name) {\n    throw new Error('Name is required to generate an asset prefix');\n  }\n\n  return `${PREFIX}-${name}`;\n}\n"],"mappings":"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","names":["forwardRef","useContext","NextLink","useState","useEffect","pathToRegexp","MicrofrontendConfigClient","config","opts","app","match","other","path","pathname","name","application","group","childPath","defaultApplication","cachedServerClientConfigPromise","fetchClientConfigFromServer","response","responseJson","MicrofrontendConfigClient","useClientConfig","config","removeFlaggedPathsFromDefault","clientConfig","setClientConfig","useState","isLoading","setIsLoading","useEffect","originalClientConfig","app","group","newConfig","prevConfig","createContext","useCallback","useEffect","useMemo","useState","Fragment","jsx","jsxs","PrefetchCrossZoneLinksContext","PrefetchCrossZoneLinksProvider","children","seenHrefs","setSeenHrefs","isSafariOrFirefox","setIsSafariOrFirefox","prefetchHref","href","value","useEffect","useState","Script","jsx","PREFETCH_ATTR","DATA_ATTR_SELECTORS","PREFETCH_ON_HOVER_PREDICATES","PREFETCH_WHEN_VISIBLE_PREDICATES","checkVisibility","element","el","style","PrefetchCrossZoneLinks","isLoading","useClientConfig","links","setLinks","useState","useEffect","observer","entries","entry","link","mutations","mutation","Script","jsx","CURRENT_ZONE","useZoneForHref","href","clientConfig","isLoading","useClientConfig","isRelativePath","zoneOfHref","Link","forwardRef","children","props","ref","prefetchHref","useContext","PrefetchCrossZoneLinksContext","isDifferentZone","onHoverPrefetch","_","rest","NextLink","forwardRef","NextImage","getImageProps","PREFIX","generateAssetPrefixFromName","name","jsx","CURRENT_ZONE","loaderWithAssetPrefix","assetPrefix","src","Image","forwardRef","props","ref","clientConfig","useClientConfig","generateAssetPrefixFromName","getImageProps","NextImage"]}