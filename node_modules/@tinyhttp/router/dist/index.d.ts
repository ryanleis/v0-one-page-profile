export declare type NextFunction = (err?: any) => void;
export declare type SyncHandler<Request extends any = any, Response extends any = any> = (req: Request, res: Response, next: NextFunction) => void;
export declare type AsyncHandler<Request extends any = any, Response extends any = any> = (req: Request, res: Response, next: NextFunction) => Promise<void>;
export declare type Handler<Request extends any = any, Response extends any = any> = AsyncHandler<Request, Response> | SyncHandler<Request, Response>;
declare const METHODS: readonly ["ACL", "BIND", "CHECKOUT", "CONNECT", "COPY", "DELETE", "GET", "HEAD", "LINK", "LOCK", "M-SEARCH", "MERGE", "MKACTIVITY", "MKCALENDAR", "MKCOL", "MOVE", "NOTIFY", "OPTIONS", "PATCH", "POST", "PRI", "PROPFIND", "PROPPATCH", "PURGE", "PUT", "REBIND", "REPORT", "SEARCH", "SOURCE", "SUBSCRIBE", "TRACE", "UNBIND", "UNLINK", "UNLOCK", "UNSUBSCRIBE"];
export declare type Method = typeof METHODS[number];
export declare type MiddlewareType = 'mw' | 'route';
declare type RegexParams = {
    keys: string[];
    pattern: RegExp;
};
declare type RIM<Req, Res, App> = (...args: RouterMethodParams<Req, Res>) => App;
export interface Middleware<Req extends any = any, Res extends any = any> {
    method?: Method;
    handler: Handler<Req, Res>;
    path?: string;
    type: MiddlewareType;
    regex?: RegexParams;
}
export declare type MethodHandler<Req extends any = any, Res extends any = any> = {
    path?: string | Handler<Req, Res>;
    handler?: Handler<Req, Res>;
    type: MiddlewareType;
    regex?: RegexParams;
};
export declare type RouterHandler<Req extends any = any, Res extends any = any> = Handler<Req, Res> | Handler<Req, Res>[];
export declare type RouterPathOrHandler<Req extends any = any, Res extends any = any> = string | RouterHandler<Req, Res>;
export declare type RouterMethod<Req extends any = any, Res extends any = any> = (path: string | Handler<Req, Res>, handler?: RouterHandler<Req, Res>, ...handlers: RouterHandler<Req, Res>[]) => any;
declare type RouterMethodParams<Req extends any = any, Res extends any = any> = Parameters<RouterMethod<Req, Res>>;
export declare type UseMethod<Req extends any = any, Res extends any = any, App extends Router = any> = (path: RouterPathOrHandler<Req, Res> | App, handler?: RouterHandler<Req, Res> | App, ...handlers: RouterHandler<Req, Res>[]) => any;
export declare type UseMethodParams<Req extends any = any, Res extends any = any, App extends Router = any> = Parameters<UseMethod<Req, Res, App>>;
/**
 * Push wares to a middleware array
 * @param mw Middleware arrays
 */
export declare const pushMiddleware: <Req extends unknown = any, Res extends unknown = any>(mw: Middleware[]) => ({ path, handler, method, handlers, type }: MethodHandler<Req, Res> & {
    method?: Method;
    handlers?: RouterHandler<Req, Res>[];
}) => void;
/**
 * tinyhttp Router. Manages middleware and has HTTP methods aliases, e.g. `app.get`, `app.put`
 */
export declare class Router<App extends Router = any, Req extends any = any, Res extends any = any> {
    middleware: Middleware[];
    mountpath: string;
    parent: App;
    apps: Record<string, App>;
    acl: RIM<Req, Res, this>;
    bind: RIM<Req, Res, this>;
    checkout: RIM<Req, Res, this>;
    connect: RIM<Req, Res, this>;
    copy: RIM<Req, Res, this>;
    delete: RIM<Req, Res, this>;
    get: RIM<Req, Res, this>;
    head: RIM<Req, Res, this>;
    link: RIM<Req, Res, this>;
    lock: RIM<Req, Res, this>;
    merge: RIM<Req, Res, this>;
    mkactivity: RIM<Req, Res, this>;
    mkcalendar: RIM<Req, Res, this>;
    mkcol: RIM<Req, Res, this>;
    move: RIM<Req, Res, this>;
    notify: RIM<Req, Res, this>;
    options: RIM<Req, Res, this>;
    patch: RIM<Req, Res, this>;
    post: RIM<Req, Res, this>;
    pri: RIM<Req, Res, this>;
    propfind: RIM<Req, Res, this>;
    proppatch: RIM<Req, Res, this>;
    purge: RIM<Req, Res, this>;
    put: RIM<Req, Res, this>;
    rebind: RIM<Req, Res, this>;
    report: RIM<Req, Res, this>;
    search: RIM<Req, Res, this>;
    source: RIM<Req, Res, this>;
    subscribe: RIM<Req, Res, this>;
    trace: RIM<Req, Res, this>;
    unbind: RIM<Req, Res, this>;
    unlink: RIM<Req, Res, this>;
    unlock: RIM<Req, Res, this>;
    unsubscribe: RIM<Req, Res, this>;
    constructor();
    add(method: Method): (path: string | Handler<Req, Res>, handler?: RouterHandler<Req, Res>, ...handlers: RouterHandler<Req, Res>[]) => this;
    msearch(...args: RouterMethodParams<Req, Res>): this;
    all(...args: RouterMethodParams<Req, Res>): this;
    /**
     * Return the app's absolute pathname
     * based on the parent(s) that have
     * mounted it.
     *
     * For example if the application was
     * mounted as `"/admin"`, which itself
     * was mounted as `"/blog"` then the
     * return value would be `"/blog/admin"`.
     *
     */
    path(): string;
    /**
     * Push middleware to the stack
     */
    use(...args: UseMethodParams<Req, Res, App>): this;
}
export {};
