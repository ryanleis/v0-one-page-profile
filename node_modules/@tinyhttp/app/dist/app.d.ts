/// <reference types="node" />
import { Server } from 'http';
import type { Request } from './request';
import type { Response } from './response';
import type { ErrorHandler } from './onError';
import { Middleware, Handler, NextFunction, Router, UseMethodParams } from '@tinyhttp/router';
export declare const applyHandler: <Req, Res>(h: Handler<Req, Res>) => (req: Req, res: Res, next?: NextFunction) => Promise<void>;
/**
 * tinyhttp App has a few settings for toggling features
 */
export declare type AppSettings = Partial<{
    networkExtensions: boolean;
    freshnessTesting: boolean;
    subdomainOffset: number;
    bindAppToReqRes: boolean;
    xPoweredBy: string | boolean;
    enableReqRoute: boolean;
}>;
/**
 * Function that processes the template
 */
export declare type TemplateFunc<O> = (path: string, locals: Record<string, any>, opts: TemplateEngineOptions<O>, cb: (err: Error, html: unknown) => void) => void;
export declare type TemplateEngineOptions<O = any> = Partial<{
    cache: boolean;
    ext: string;
    renderOptions: Partial<O>;
    viewsFolder: string;
    _locals: Record<string, any>;
}>;
/**
 * `App` class - the starting point of tinyhttp app.
 *
 * With the `App` you can:
 * * use routing methods and `.use(...)`
 * * set no match (404) and error (500) handlers
 * * configure template engines
 * * store data in locals
 * * listen the http server on a specified port
 *
 * In case you use TypeScript, you can pass custom types to this class because it is also a generic class.
 *
 * Example:
 *
 * ```ts
 * interface CoolReq extends Request {
 *  genericsAreDope: boolean
 * }
 *
 * const app = App<any, CoolReq, Response>()
 * ```
 */
export declare class App<RenderOptions = any, Req extends Request = Request, Res extends Response<RenderOptions> = Response<RenderOptions>> extends Router<App, Req, Res> {
    middleware: Middleware<Req, Res>[];
    locals: Record<string, string>;
    noMatchHandler: Handler;
    onError: ErrorHandler;
    settings: AppSettings;
    engines: Record<string, TemplateFunc<RenderOptions>>;
    applyExtensions: (req: Request, res: Response, next: NextFunction) => void;
    attach: (req: Req, res: Res) => void;
    constructor(options?: Partial<{
        noMatchHandler: Handler<Req, Res>;
        onError: ErrorHandler;
        settings: AppSettings;
        applyExtensions: (req: Request, res: Response, next: NextFunction) => void;
    }>);
    /**
     * Set app setting
     * @param setting setting name
     * @param value setting value
     */
    set(setting: string, value: any): this;
    /**
     * Enable app setting
     * @param setting Setting name
     */
    enable(setting: string): this;
    /**
     * Disable app setting
     * @param setting
     */
    disable(setting: string): this;
    /**
     * Render a template
     * @param file What to render
     * @param data data that is passed to a template
     * @param options Template engine options
     * @param cb Callback that consumes error and html
     */
    render(file: string, data: Record<string, any>, cb: (err: unknown, html: unknown) => void, options?: TemplateEngineOptions<RenderOptions>): this;
    use(...args: UseMethodParams<Req, Res, App>): this;
    /**
     * Register a template engine with extension
     */
    engine(ext: string, fn: TemplateFunc<RenderOptions>): this;
    route(path: string): App;
    find(url: string): Middleware<Req, Res>[];
    /**
     * Extends Req / Res objects, pushes 404 and 500 handlers, dispatches middleware
     * @param req Req object
     * @param res Res object
     */
    handler(req: Req, res: Res, next?: NextFunction): void;
    /**
     * Creates HTTP server and dispatches middleware
     * @param port server listening port
     * @param Server callback after server starts listening
     * @param host server listening host
     */
    listen(port?: number, cb?: () => void, host?: string): Server;
}
