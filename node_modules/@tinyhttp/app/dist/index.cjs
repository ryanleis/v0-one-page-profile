'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var http = require('http');
var path = require('path');
var proxyAddr = require('@tinyhttp/proxy-addr');
var net = require('net');
var req = require('@tinyhttp/req');
var router = require('@tinyhttp/router');
var res = require('@tinyhttp/res');
var rg = require('regexparam');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var path__default = /*#__PURE__*/_interopDefaultLegacy(path);
var rg__default = /*#__PURE__*/_interopDefaultLegacy(rg);

const trustRemoteAddress = ({ connection }) => {
    const val = connection.remoteAddress;
    if (typeof val === 'function')
        return val;
    if (typeof val === 'boolean' && val === true)
        return () => true;
    if (typeof val === 'number')
        return (_, i) => (val ? i < val : undefined);
    if (typeof val === 'string')
        return proxyAddr.compile(val.split(',').map((x) => x.trim()));
    return proxyAddr.compile(val || []);
};
const getRouteFromApp = ({ middleware }, h) => middleware.find(({ handler }) => typeof handler === 'function' && handler.name === h.name);
const getProtocol = (req) => {
    const proto = req.connection.encrypted ? 'https' : 'http';
    if (!trustRemoteAddress(req))
        return proto;
    const header = req.headers['X-Forwarded-Proto'] || proto;
    const index = header.indexOf(',');
    return index !== -1 ? header.substring(0, index).trim() : header.trim();
};
const getHostname = (req) => {
    let host = req.get('X-Forwarded-Host');
    if (!host || !trustRemoteAddress(req))
        host = req.get('Host');
    if (!host)
        return;
    // IPv6 literal support
    const index = host.indexOf(':', host[0] === '[' ? host.indexOf(']') + 1 : 0);
    return index !== -1 ? host.substring(0, index) : host;
};
const getIP = (req) => proxyAddr.proxyaddr(req, trustRemoteAddress(req)).replace(/^.*:/, ''); // striping the redundant prefix addeded by OS to IPv4 address
const getIPs = (req) => proxyAddr.all(req, trustRemoteAddress(req));
const getSubdomains = (req, subdomainOffset = 2) => {
    const hostname = getHostname(req);
    if (!hostname)
        return [];
    const subdomains = net.isIP(hostname) ? [hostname] : hostname.split('.').reverse();
    return subdomains.slice(subdomainOffset);
};

const onErrorHandler = (err, _req, res) => {
    console.error(err);
    const code = err.code in http.STATUS_CODES ? err.code : err.status;
    if (typeof err === 'string' || Buffer.isBuffer(err))
        res.writeHead(500).end(err);
    else if (code in http.STATUS_CODES)
        res.writeHead(code).end(http.STATUS_CODES[code]);
    else
        res.writeHead(500).end(err.message);
};

const renderTemplate = (_req, res, app) => (file, data, options) => {
    app.render(file, data, (err, html) => {
        if (err)
            throw err;
        res.send(html);
    }, options);
    return res;
};

/**
 * Extends Request and Response objects with custom properties and methods
 */
const extendMiddleware = (app) => (req$1, res$1, next) => {
    const { settings } = app;
    res$1.get = res.getResponseHeader(res$1);
    req$1.get = req.getRequestHeader(req$1);
    if (settings === null || settings === void 0 ? void 0 : settings.bindAppToReqRes) {
        req$1.app = app;
        res$1.app = app;
    }
    if (settings === null || settings === void 0 ? void 0 : settings.networkExtensions) {
        req$1.protocol = getProtocol(req$1);
        req$1.secure = req$1.protocol === 'https';
        req$1.connection = Object.assign(req$1.socket, { encrypted: req$1.secure });
        req$1.hostname = getHostname(req$1);
        req$1.subdomains = getSubdomains(req$1, settings.subdomainOffset);
        req$1.ip = getIP(req$1);
        req$1.ips = getIPs(req$1);
    }
    req$1.query = req.getQueryParams(req$1.url);
    req$1.range = req.getRangeFromHeader(req$1);
    req$1.accepts = req.getAccepts(req$1);
    req$1.acceptsCharsets = req.getAcceptsCharsets(req$1);
    req$1.acceptsEncodings = req.getAcceptsEncodings(req$1);
    req$1.acceptsLanguages = req.getAcceptsLanguages(req$1);
    req$1.xhr = req.checkIfXMLHttpRequest(req$1);
    res$1.header = res$1.set = res.setHeader(res$1);
    res$1.send = res.send(req$1, res$1);
    res$1.json = res.json(res$1);
    res$1.status = res.status(res$1);
    res$1.sendStatus = res.sendStatus(req$1, res$1);
    res$1.sendFile = res.sendFile(req$1, res$1);
    res$1.type = res.setContentType(res$1);
    res$1.location = res.setLocationHeader(req$1, res$1);
    res$1.links = res.setLinksHeader(res$1);
    res$1.vary = res.setVaryHeader(res$1);
    res$1.cookie = res.setCookie(req$1, res$1);
    res$1.clearCookie = res.clearCookie(req$1, res$1);
    res$1.render = renderTemplate(req$1, res$1, app);
    res$1.format = res.formatResponse(req$1, res$1, next);
    res$1.redirect = res.redirect(req$1, res$1, next);
    res$1.attachment = res.attachment(res$1);
    res$1.download = res.download(req$1, res$1);
    res$1.append = res.append(res$1);
    res$1.locals = res$1.locals || Object.create(null);
    if (settings === null || settings === void 0 ? void 0 : settings.freshnessTesting) {
        req$1.fresh = req.getFreshOrStale.bind(null, req$1, res$1);
        req$1.stale = !req$1.fresh;
    }
    next();
};

/**
 * Add leading slash if not present (e.g. path -> /path, /path -> /path)
 * @param x
 */
const lead = (x) => (x.charCodeAt(0) === 47 ? x : '/' + x);
const mount = (fn) => (fn instanceof App ? fn.attach : fn);
const applyHandler = (h) => async (req, res, next) => {
    try {
        if (h[Symbol.toStringTag] === 'AsyncFunction') {
            await h(req, res, next);
        }
        else
            h(req, res, next);
    }
    catch (e) {
        next(e);
    }
};
/**
 * `App` class - the starting point of tinyhttp app.
 *
 * With the `App` you can:
 * * use routing methods and `.use(...)`
 * * set no match (404) and error (500) handlers
 * * configure template engines
 * * store data in locals
 * * listen the http server on a specified port
 *
 * In case you use TypeScript, you can pass custom types to this class because it is also a generic class.
 *
 * Example:
 *
 * ```ts
 * interface CoolReq extends Request {
 *  genericsAreDope: boolean
 * }
 *
 * const app = App<any, CoolReq, Response>()
 * ```
 */
class App extends router.Router {
    constructor(options = {}) {
        super();
        this.middleware = [];
        this.locals = {};
        this.engines = {};
        this.onError = (options === null || options === void 0 ? void 0 : options.onError) || onErrorHandler;
        this.noMatchHandler = (options === null || options === void 0 ? void 0 : options.noMatchHandler) || this.onError.bind(null, { code: 404 });
        this.settings = options.settings || { xPoweredBy: true };
        this.applyExtensions = options === null || options === void 0 ? void 0 : options.applyExtensions;
        this.attach = (req, res) => setImmediate(this.handler.bind(this, req, res, undefined), req, res);
    }
    /**
     * Set app setting
     * @param setting setting name
     * @param value setting value
     */
    set(setting, value) {
        this.settings[setting] = value;
        return this;
    }
    /**
     * Enable app setting
     * @param setting Setting name
     */
    enable(setting) {
        this.settings[setting] = true;
        return this;
    }
    /**
     * Disable app setting
     * @param setting
     */
    disable(setting) {
        this.settings[setting] = false;
        return this;
    }
    /**
     * Render a template
     * @param file What to render
     * @param data data that is passed to a template
     * @param options Template engine options
     * @param cb Callback that consumes error and html
     */
    render(file, data = {}, cb, options = {}) {
        options.viewsFolder = options.viewsFolder || `${process.cwd()}/views`;
        options.ext = options.ext || file.slice(file.lastIndexOf('.') + 1) || 'ejs';
        options._locals = options._locals || {};
        options.cache = options.cache || process.env.NODE_ENV === 'production';
        let locals = { ...data, ...this.locals };
        if (options._locals)
            locals = { ...locals, ...options._locals };
        if (!file.endsWith(`.${options.ext}`))
            file = `${file}.${options.ext}`;
        const dest = options.viewsFolder ? path__default['default'].join(options.viewsFolder, file) : file;
        this.engines[options.ext](dest, locals, options.renderOptions, cb);
        return this;
    }
    use(...args) {
        const base = args[0];
        const fns = args.slice(1).flat();
        if (base instanceof App) {
            // Set App parent to current App
            base.parent = this;
            // Mount on root
            base.mountpath = '/';
            this.apps['/'] = base;
        }
        const path = typeof base === 'string' ? base : '/';
        let regex;
        for (const fn of fns) {
            if (fn instanceof App) {
                regex = rg__default['default'](path, true);
                fn.mountpath = path;
                this.apps[path] = fn;
                fn.parent = this;
            }
        }
        if (base === '/') {
            for (const fn of fns)
                super.use(base, mount(fn));
        }
        else if (typeof base === 'function' || base instanceof App) {
            super.use('/', [base, ...fns].map(mount));
        }
        else if (Array.isArray(base)) {
            super.use('/', [...base, ...fns].map(mount));
        }
        else {
            router.pushMiddleware(this.middleware)({
                path: base,
                regex,
                type: 'mw',
                handler: mount(fns[0]),
                handlers: fns.slice(1).map(mount)
            });
        }
        return this; // chainable
    }
    /**
     * Register a template engine with extension
     */
    engine(ext, fn) {
        this.engines[ext] = fn;
        return this;
    }
    route(path) {
        const app = new App();
        this.use(path, app);
        return app;
    }
    find(url) {
        return this.middleware.filter((m) => {
            m.regex = m.regex || rg__default['default'](m.path, m.type === 'mw');
            return m.regex.pattern.test(url);
        });
    }
    /**
     * Extends Req / Res objects, pushes 404 and 500 handlers, dispatches middleware
     * @param req Req object
     * @param res Res object
     */
    handler(req$1, res, next) {
        /* Set X-Powered-By header */
        const { xPoweredBy } = this.settings;
        if (xPoweredBy)
            res.setHeader('X-Powered-By', typeof xPoweredBy === 'string' ? xPoweredBy : 'tinyhttp');
        const exts = this.applyExtensions || extendMiddleware(this);
        req$1.originalUrl = req$1.url || req$1.originalUrl;
        const pathname = req.getPathname(req$1.originalUrl);
        const matched = this.find(pathname);
        const mw = [
            {
                handler: exts,
                type: 'mw',
                path: '/'
            },
            ...matched.filter((x) => (x.method ? x.method === req$1.method : true))
        ];
        if (matched[0] != null) {
            mw.push({
                type: 'mw',
                handler: (req, res, next) => {
                    if (req.method === 'HEAD') {
                        res.statusCode = 204;
                        return res.end('');
                    }
                    next();
                },
                path: '/'
            });
        }
        mw.push({
            handler: this.noMatchHandler,
            type: 'mw',
            path: '/'
        });
        const handle = (mw) => async (req$1, res, next) => {
            var _a;
            const { path, handler, type, regex } = mw;
            const params = regex ? req.getURLParams(regex, pathname) : {};
            if (type === 'route')
                req$1.params = params;
            if (path.includes(':')) {
                const url = req$1.url.slice(req$1.url.indexOf(Object.values(params)[0]) + Object.values(params)[0].length);
                req$1.url = lead(url);
            }
            else {
                req$1.url = lead(req$1.url.substring(path.length));
            }
            req$1.path = req.getPathname(req$1.url);
            if ((_a = this.settings) === null || _a === void 0 ? void 0 : _a.enableReqRoute)
                req$1.route = getRouteFromApp(this, handler);
            await applyHandler(handler)(req$1, res, next);
        };
        let idx = 0;
        const loop = () => res.writableEnded || (idx < mw.length && handle(mw[idx++])(req$1, res, next));
        next = next || ((err) => (err ? this.onError(err, req$1, res) : loop()));
        loop();
    }
    /**
     * Creates HTTP server and dispatches middleware
     * @param port server listening port
     * @param Server callback after server starts listening
     * @param host server listening host
     */
    listen(port, cb, host = '0.0.0.0') {
        return http.createServer().on('request', this.attach).listen(port, host, cb);
    }
}

Object.defineProperty(exports, 'getURLParams', {
    enumerable: true,
    get: function () {
        return req.getURLParams;
    }
});
exports.App = App;
exports.applyHandler = applyHandler;
exports.extendMiddleware = extendMiddleware;
exports.getHostname = getHostname;
exports.getIP = getIP;
exports.getIPs = getIPs;
exports.getProtocol = getProtocol;
exports.getRouteFromApp = getRouteFromApp;
exports.getSubdomains = getSubdomains;
exports.renderTemplate = renderTemplate;
