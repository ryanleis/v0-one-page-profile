'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var esMimeTypes = require('es-mime-types');
var typer = require('es-content-type');

function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = Object.create(null);
    if (e) {
        Object.keys(e).forEach(function (k) {
            if (k !== 'default') {
                var d = Object.getOwnPropertyDescriptor(e, k);
                Object.defineProperty(n, k, d.get ? d : {
                    enumerable: true,
                    get: function () {
                        return e[k];
                    }
                });
            }
        });
    }
    n['default'] = e;
    return Object.freeze(n);
}

var typer__namespace = /*#__PURE__*/_interopNamespace(typer);

function normalizeType(value) {
    // parse the type
    const type = typer__namespace.parse(value);
    type.parameters = {};
    // reformat it
    return typer__namespace.format(type);
}
function tryNormalizeType(value) {
    if (!value)
        return null;
    try {
        return normalizeType(value);
    }
    catch (err) {
        return null;
    }
}
function mimeMatch(expected, actual) {
    // invalid type
    if (expected === false)
        return false;
    // split types
    const actualParts = actual.split('/');
    const expectedParts = expected.split('/');
    // invalid format
    if (actualParts.length !== 2 || expectedParts.length !== 2)
        return false;
    // validate type
    if (expectedParts[0] !== '*' && expectedParts[0] !== actualParts[0])
        return false;
    // validate suffix wildcard
    if (expectedParts[1].substr(0, 2) === '*+')
        return (expectedParts[1].length <= actualParts[1].length + 1 &&
            expectedParts[1].substr(1) === actualParts[1].substr(1 - expectedParts[1].length));
    // validate subtype
    if (expectedParts[1] !== '*' && expectedParts[1] !== actualParts[1])
        return false;
    return true;
}
function normalize(type) {
    // invalid type
    if (typeof type !== 'string')
        return false;
    switch (type) {
        case 'urlencoded':
            return 'application/x-www-form-urlencoded';
        case 'multipart':
            return 'multipart/*';
    }
    // "+json" -> "*/*+json" expando
    if (type[0] === '+')
        return '*/*' + type;
    return type.indexOf('/') === -1 ? esMimeTypes.lookup(type) : type;
}
/**
 * Compare a `value` content-type with `types`.
 * Each `type` can be an extension like `html`,
 * a special shortcut like `multipart` or `urlencoded`,
 * or a mime type.
 */
const typeIs = (value, ...types) => {
    let i;
    // remove parameters and normalize
    const val = tryNormalizeType(value);
    // no type or invalid
    if (!val)
        return false;
    // no types, return the content type
    if (!types || !types.length)
        return val;
    let type;
    for (i = 0; i < types.length; i++) {
        if (mimeMatch(normalize((type = types[i])), val)) {
            return type[0] === '+' || type.indexOf('*') !== -1 ? val : type;
        }
    }
    // no matches
    return false;
};

exports.typeIs = typeIs;
